/* gnome-mahjongg.c generated by valac 0.22.1, the Vala compiler
 * generated from gnome-mahjongg.vala, do not modify */

/*
 * Copyright (C) 2010-2013 Robert Ancell
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version. See http://www.gnu.org/copyleft/gpl.html the full text of the
 * license.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <gdk/gdk.h>
#include <float.h>
#include <math.h>
#include <locale.h>
#include <stdio.h>
#include <pango/pango.h>


#define TYPE_MAHJONGG (mahjongg_get_type ())
#define MAHJONGG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAHJONGG, Mahjongg))
#define MAHJONGG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAHJONGG, MahjonggClass))
#define IS_MAHJONGG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAHJONGG))
#define IS_MAHJONGG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAHJONGG))
#define MAHJONGG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAHJONGG, MahjonggClass))

typedef struct _Mahjongg Mahjongg;
typedef struct _MahjonggClass MahjonggClass;
typedef struct _MahjonggPrivate MahjonggPrivate;

#define TYPE_HISTORY (history_get_type ())
#define HISTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HISTORY, History))
#define HISTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_HISTORY, HistoryClass))
#define IS_HISTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HISTORY))
#define IS_HISTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_HISTORY))
#define HISTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HISTORY, HistoryClass))

typedef struct _History History;
typedef struct _HistoryClass HistoryClass;

#define TYPE_MAP (map_get_type ())
#define MAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAP, Map))
#define MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAP, MapClass))
#define IS_MAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAP))
#define IS_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAP))
#define MAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAP, MapClass))

typedef struct _Map Map;
typedef struct _MapClass MapClass;

#define TYPE_GAME_VIEW (game_view_get_type ())
#define GAME_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_VIEW, GameView))
#define GAME_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_VIEW, GameViewClass))
#define IS_GAME_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_VIEW))
#define IS_GAME_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_VIEW))
#define GAME_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_VIEW, GameViewClass))

typedef struct _GameView GameView;
typedef struct _GameViewClass GameViewClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _history_unref0(var) ((var == NULL) ? NULL : (var = (history_unref (var), NULL)))
#define __g_list_free__map_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__map_unref0_ (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _GameViewPrivate GameViewPrivate;

#define TYPE_GAME (game_get_type ())
#define GAME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME, Game))
#define GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME, GameClass))
#define IS_GAME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME))
#define IS_GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME))
#define GAME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME, GameClass))

typedef struct _Game Game;
typedef struct _GameClass GameClass;
typedef struct _MapPrivate MapPrivate;

#define TYPE_SLOT (slot_get_type ())
#define SLOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SLOT, Slot))
#define SLOT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SLOT, SlotClass))
#define IS_SLOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SLOT))
#define IS_SLOT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SLOT))
#define SLOT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SLOT, SlotClass))

typedef struct _Slot Slot;
typedef struct _SlotClass SlotClass;

#define TYPE_HISTORY_ENTRY (history_entry_get_type ())
#define HISTORY_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_HISTORY_ENTRY, HistoryEntry))
#define HISTORY_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_HISTORY_ENTRY, HistoryEntryClass))
#define IS_HISTORY_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_HISTORY_ENTRY))
#define IS_HISTORY_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_HISTORY_ENTRY))
#define HISTORY_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_HISTORY_ENTRY, HistoryEntryClass))

typedef struct _HistoryEntry HistoryEntry;
typedef struct _HistoryEntryClass HistoryEntryClass;
typedef struct _GamePrivate GamePrivate;

#define TYPE_TILE (tile_get_type ())
#define TILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TILE, Tile))
#define TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TILE, TileClass))
#define IS_TILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TILE))
#define IS_TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TILE))
#define TILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TILE, TileClass))

typedef struct _Tile Tile;
typedef struct _TileClass TileClass;
#define _history_entry_unref0(var) ((var == NULL) ? NULL : (var = (history_entry_unref (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))

#define TYPE_SCORE_DIALOG (score_dialog_get_type ())
#define SCORE_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCORE_DIALOG, ScoreDialog))
#define SCORE_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCORE_DIALOG, ScoreDialogClass))
#define IS_SCORE_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCORE_DIALOG))
#define IS_SCORE_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCORE_DIALOG))
#define SCORE_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCORE_DIALOG, ScoreDialogClass))

typedef struct _ScoreDialog ScoreDialog;
typedef struct _ScoreDialogClass ScoreDialogClass;
#define _map_unref0(var) ((var == NULL) ? NULL : (var = (map_unref (var), NULL)))
#define __g_list_free__g_free0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_free0_ (var), NULL)))
#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))

#define TYPE_MATCH (match_get_type ())
#define MATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MATCH, Match))
#define MATCH_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MATCH, MatchClass))
#define IS_MATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MATCH))
#define IS_MATCH_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MATCH))
#define MATCH_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MATCH, MatchClass))

typedef struct _Match Match;
typedef struct _MatchClass MatchClass;
#define __g_list_free__match_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__match_unref0_ (var), NULL)))
typedef struct _MatchPrivate MatchPrivate;
#define _match_unref0(var) ((var == NULL) ? NULL : (var = (match_unref (var), NULL)))
#define _game_unref0(var) ((var == NULL) ? NULL : (var = (game_unref (var), NULL)))

#define TYPE_MAP_LOADER (map_loader_get_type ())
#define MAP_LOADER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAP_LOADER, MapLoader))
#define MAP_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAP_LOADER, MapLoaderClass))
#define IS_MAP_LOADER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAP_LOADER))
#define IS_MAP_LOADER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAP_LOADER))
#define MAP_LOADER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAP_LOADER, MapLoaderClass))

typedef struct _MapLoader MapLoader;
typedef struct _MapLoaderClass MapLoaderClass;
#define _map_loader_unref0(var) ((var == NULL) ? NULL : (var = (map_loader_unref (var), NULL)))
typedef struct _MapLoaderPrivate MapLoaderPrivate;
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))
typedef struct _ScoreDialogPrivate ScoreDialogPrivate;
typedef struct _HistoryPrivate HistoryPrivate;
typedef struct _HistoryEntryPrivate HistoryEntryPrivate;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))

struct _Mahjongg {
	GtkApplication parent_instance;
	MahjonggPrivate * priv;
};

struct _MahjonggClass {
	GtkApplicationClass parent_class;
};

struct _MahjonggPrivate {
	GSettings* settings;
	History* history;
	GList* maps;
	GtkApplicationWindow* window;
	gint window_width;
	gint window_height;
	gboolean is_fullscreen;
	gboolean is_maximized;
	GameView* game_view;
	GtkToolButton* pause_button;
	GtkToolItem* status_item;
	GtkLabel* moves_label;
	GtkLabel* clock_label;
	GtkDialog* preferences_dialog;
};

struct _GameView {
	GtkDrawingArea parent_instance;
	GameViewPrivate * priv;
	GdkRGBA background_color;
	gboolean auto_play;
};

struct _GameViewClass {
	GtkDrawingAreaClass parent_class;
};

struct _Map {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MapPrivate * priv;
	gchar* name;
	gchar* score_name;
	GList* slots;
};

struct _MapClass {
	GTypeClass parent_class;
	void (*finalize) (Map *self);
};

struct _Game {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GamePrivate * priv;
	Map* map;
	GList* tiles;
	Tile* hint_tiles[2];
	GList** sets;
	gint sets_length1;
	gint move_number;
	guint hint_blink_counter;
};

struct _GameClass {
	GTypeClass parent_class;
	void (*finalize) (Game *self);
};

struct _Match {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MatchPrivate * priv;
	Tile* tile0;
	Tile* tile1;
};

struct _MatchClass {
	GTypeClass parent_class;
	void (*finalize) (Match *self);
};

struct _MapLoader {
	GTypeInstance parent_instance;
	volatile int ref_count;
	MapLoaderPrivate * priv;
	GList* maps;
};

struct _MapLoaderClass {
	GTypeClass parent_class;
	void (*finalize) (MapLoader *self);
};

struct _ScoreDialog {
	GtkDialog parent_instance;
	ScoreDialogPrivate * priv;
};

struct _ScoreDialogClass {
	GtkDialogClass parent_class;
};

struct _ScoreDialogPrivate {
	History* history;
	HistoryEntry* selected_entry;
	GtkListStore* size_model;
	GtkListStore* score_model;
	GtkComboBox* size_combo;
};

struct _History {
	GTypeInstance parent_instance;
	volatile int ref_count;
	HistoryPrivate * priv;
	gchar* filename;
	GList* entries;
};

struct _HistoryClass {
	GTypeClass parent_class;
	void (*finalize) (History *self);
};

struct _HistoryEntry {
	GTypeInstance parent_instance;
	volatile int ref_count;
	HistoryEntryPrivate * priv;
	GDateTime* date;
	gchar* name;
	guint duration;
};

struct _HistoryEntryClass {
	GTypeClass parent_class;
	void (*finalize) (HistoryEntry *self);
};


static gpointer mahjongg_parent_class = NULL;
static gpointer score_dialog_parent_class = NULL;

GType mahjongg_get_type (void) G_GNUC_CONST;
gpointer history_ref (gpointer instance);
void history_unref (gpointer instance);
GParamSpec* param_spec_history (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_history (GValue* value, gpointer v_object);
void value_take_history (GValue* value, gpointer v_object);
gpointer value_get_history (const GValue* value);
GType history_get_type (void) G_GNUC_CONST;
gpointer map_ref (gpointer instance);
void map_unref (gpointer instance);
GParamSpec* param_spec_map (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_map (GValue* value, gpointer v_object);
void value_take_map (GValue* value, gpointer v_object);
gpointer value_get_map (const GValue* value);
GType map_get_type (void) G_GNUC_CONST;
GType game_view_get_type (void) G_GNUC_CONST;
#define MAHJONGG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MAHJONGG, MahjonggPrivate))
enum  {
	MAHJONGG_DUMMY_PROPERTY
};
static void _map_unref0_ (gpointer var);
static void _g_list_free__map_unref0_ (GList* self);
static void mahjongg_new_game_cb (Mahjongg* self);
static void _mahjongg_new_game_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_undo_cb (Mahjongg* self);
static void _mahjongg_undo_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_redo_cb (Mahjongg* self);
static void _mahjongg_redo_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_hint_cb (Mahjongg* self);
static void _mahjongg_hint_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_pause_cb (Mahjongg* self);
static void _mahjongg_pause_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_restart_game_cb (Mahjongg* self);
static void _mahjongg_restart_game_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_scores_cb (Mahjongg* self);
static void _mahjongg_scores_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_preferences_cb (Mahjongg* self);
static void _mahjongg_preferences_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_help_cb (Mahjongg* self);
static void _mahjongg_help_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_about_cb (Mahjongg* self);
static void _mahjongg_about_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
static void mahjongg_quit_cb (Mahjongg* self);
static void _mahjongg_quit_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self);
Mahjongg* mahjongg_new (void);
Mahjongg* mahjongg_construct (GType object_type);
static void mahjongg_real_startup (GApplication* base);
static void mahjongg_load_maps (Mahjongg* self);
History* history_new (const gchar* filename);
History* history_construct (GType object_type, const gchar* filename);
void history_load (History* self);
static gboolean mahjongg_window_configure_event_cb (Mahjongg* self, GdkEventConfigure* event);
static gboolean _mahjongg_window_configure_event_cb_gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
static gboolean mahjongg_window_state_event_cb (Mahjongg* self, GdkEventWindowState* event);
static gboolean _mahjongg_window_state_event_cb_gtk_widget_window_state_event (GtkWidget* _sender, GdkEventWindowState* event, gpointer self);
GameView* game_view_new (void);
GameView* game_view_construct (GType object_type);
static gboolean mahjongg_view_button_press_event (Mahjongg* self, GtkWidget* widget, GdkEventButton* event);
static gboolean _mahjongg_view_button_press_event_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self);
static void mahjongg_conf_value_changed_cb (Mahjongg* self, GSettings* settings, const gchar* key);
static void _mahjongg_conf_value_changed_cb_g_settings_changed (GSettings* _sender, const gchar* key, gpointer self);
static void mahjongg_new_game (Mahjongg* self);
static void mahjongg_tick_cb (Mahjongg* self);
static void mahjongg_real_shutdown (GApplication* base);
static void mahjongg_real_activate (GApplication* base);
static void mahjongg_update_ui (Mahjongg* self);
gpointer game_ref (gpointer instance);
void game_unref (gpointer instance);
GParamSpec* param_spec_game (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_game (GValue* value, gpointer v_object);
void value_take_game (GValue* value, gpointer v_object);
gpointer value_get_game (const GValue* value);
GType game_get_type (void) G_GNUC_CONST;
Game* game_view_get_game (GameView* self);
gboolean game_get_started (Game* self);
gboolean game_get_paused (Game* self);
guint game_get_moves_left (Game* self);
gboolean game_get_can_undo (Game* self);
gboolean game_get_can_redo (Game* self);
static void mahjongg_theme_changed_cb (Mahjongg* self, GtkComboBox* widget);
void game_view_set_theme (GameView* self, const gchar* value);
void game_view_set_background (GameView* self, const gchar* colour);
void game_set_paused (Game* self, gboolean value);
static void mahjongg_background_changed_cb (Mahjongg* self, GtkColorButton* widget);
static void mahjongg_map_changed_cb (Mahjongg* self, GtkComboBox* widget);
gpointer slot_ref (gpointer instance);
void slot_unref (gpointer instance);
GParamSpec* param_spec_slot (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_slot (GValue* value, gpointer v_object);
void value_take_slot (GValue* value, gpointer v_object);
gpointer value_get_slot (const GValue* value);
GType slot_get_type (void) G_GNUC_CONST;
static void mahjongg_toggle_auto_play_cb (Mahjongg* self, GtkToggleButton* widget);
void game_auto_move (Game* self);
static void mahjongg_moved_cb (Mahjongg* self);
gboolean game_get_complete (Game* self);
gdouble game_get_elapsed (Game* self);
gpointer history_entry_ref (gpointer instance);
void history_entry_unref (gpointer instance);
GParamSpec* param_spec_history_entry (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_history_entry (GValue* value, gpointer v_object);
void value_take_history_entry (GValue* value, gpointer v_object);
gpointer value_get_history_entry (const GValue* value);
GType history_entry_get_type (void) G_GNUC_CONST;
gpointer tile_ref (gpointer instance);
void tile_unref (gpointer instance);
GParamSpec* param_spec_tile (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_tile (GValue* value, gpointer v_object);
void value_take_tile (GValue* value, gpointer v_object);
gpointer value_get_tile (const GValue* value);
GType tile_get_type (void) G_GNUC_CONST;
HistoryEntry* history_entry_new (GDateTime* date, const gchar* name, guint duration);
HistoryEntry* history_entry_construct (GType object_type, GDateTime* date, const gchar* name, guint duration);
void history_add (History* self, HistoryEntry* entry);
void history_save (History* self);
static gint mahjongg_show_scores (Mahjongg* self, HistoryEntry* selected_entry, gboolean show_quit);
gboolean game_get_can_move (Game* self);
static void mahjongg_restart_game (Mahjongg* self);
GType score_dialog_get_type (void) G_GNUC_CONST;
ScoreDialog* score_dialog_new (History* history, HistoryEntry* selected_entry, gboolean show_quit);
ScoreDialog* score_dialog_construct (GType object_type, History* history, HistoryEntry* selected_entry, gboolean show_quit);
static void mahjongg_preferences_dialog_response_cb (Mahjongg* self, GtkDialog* dialog, gint response);
static void _mahjongg_preferences_dialog_response_cb_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
static GList* mahjongg_load_themes (Mahjongg* self);
static void _mahjongg_theme_changed_cb_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
static void _mahjongg_map_changed_cb_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
static void _mahjongg_background_changed_cb_gtk_color_button_color_set (GtkColorButton* _sender, gpointer self);
static void _mahjongg_toggle_auto_play_cb_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void _g_free0_ (gpointer var);
static void _g_list_free__g_free0_ (GList* self);
gpointer match_ref (gpointer instance);
void match_unref (gpointer instance);
GParamSpec* param_spec_match (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_match (GValue* value, gpointer v_object);
void value_take_match (GValue* value, gpointer v_object);
gpointer value_get_match (const GValue* value);
GType match_get_type (void) G_GNUC_CONST;
GList* game_find_matches (Game* self, Tile* tile);
Tile* game_get_selected_tile (Game* self);
static void _match_unref0_ (gpointer var);
static void _g_list_free__match_unref0_ (GList* self);
void game_set_hint (Game* self, Tile* tile0, Tile* tile1);
void game_set_selected_tile (Game* self, Tile* value);
void game_reset (Game* self);
void game_redo (Game* self);
void game_undo (Game* self);
Game* game_new (Map* map);
Game* game_construct (GType object_type, Map* map);
void game_view_set_game (GameView* self, Game* value);
static void _mahjongg_moved_cb_game_moved (Game* _sender, gpointer self);
static void _mahjongg_tick_cb_game_tick (Game* _sender, gpointer self);
Map* map_new_builtin (void);
Map* map_construct_builtin (GType object_type);
gpointer map_loader_ref (gpointer instance);
void map_loader_unref (gpointer instance);
GParamSpec* param_spec_map_loader (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_map_loader (GValue* value, gpointer v_object);
void value_take_map_loader (GValue* value, gpointer v_object);
gpointer value_get_map_loader (const GValue* value);
GType map_loader_get_type (void) G_GNUC_CONST;
MapLoader* map_loader_new (void);
MapLoader* map_loader_construct (GType object_type);
void map_loader_load (MapLoader* self, const gchar* filename, GError** error);
gint mahjongg_main (gchar** args, int args_length1);
static void mahjongg_finalize (GObject* obj);
#define SCORE_DIALOG_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SCORE_DIALOG, ScoreDialogPrivate))
enum  {
	SCORE_DIALOG_DUMMY_PROPERTY
};
static void score_dialog_entry_added_cb (ScoreDialog* self, HistoryEntry* entry);
static void _score_dialog_entry_added_cb_history_entry_added (History* _sender, HistoryEntry* entry, gpointer self);
static void score_dialog_size_changed_cb (ScoreDialog* self, GtkComboBox* combo);
static void _score_dialog_size_changed_cb_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self);
void score_dialog_set_map (ScoreDialog* self, const gchar* name);
static gint score_dialog_compare_entries (HistoryEntry* a, HistoryEntry* b);
static gint _score_dialog_compare_entries_gcompare_func (gconstpointer a, gconstpointer b);
static void score_dialog_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const GActionEntry MAHJONGG_action_entries[11] = {{"new-game", _mahjongg_new_game_cb_gsimple_action_activate_callback}, {"undo", _mahjongg_undo_cb_gsimple_action_activate_callback}, {"redo", _mahjongg_redo_cb_gsimple_action_activate_callback}, {"hint", _mahjongg_hint_cb_gsimple_action_activate_callback}, {"pause", _mahjongg_pause_cb_gsimple_action_activate_callback}, {"restart-game", _mahjongg_restart_game_cb_gsimple_action_activate_callback}, {"scores", _mahjongg_scores_cb_gsimple_action_activate_callback}, {"preferences", _mahjongg_preferences_cb_gsimple_action_activate_callback}, {"help", _mahjongg_help_cb_gsimple_action_activate_callback}, {"about", _mahjongg_about_cb_gsimple_action_activate_callback}, {"quit", _mahjongg_quit_cb_gsimple_action_activate_callback}};

static void _map_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (map_unref (var), NULL));
}


static void _g_list_free__map_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _map_unref0_, NULL);
	g_list_free (self);
}


static void _mahjongg_new_game_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_new_game_cb (self);
}


static void _mahjongg_undo_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_undo_cb (self);
}


static void _mahjongg_redo_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_redo_cb (self);
}


static void _mahjongg_hint_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_hint_cb (self);
}


static void _mahjongg_pause_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_pause_cb (self);
}


static void _mahjongg_restart_game_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_restart_game_cb (self);
}


static void _mahjongg_scores_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_scores_cb (self);
}


static void _mahjongg_preferences_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_preferences_cb (self);
}


static void _mahjongg_help_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_help_cb (self);
}


static void _mahjongg_about_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_about_cb (self);
}


static void _mahjongg_quit_cb_gsimple_action_activate_callback (GSimpleAction* action, GVariant* parameter, gpointer self) {
	mahjongg_quit_cb (self);
}


Mahjongg* mahjongg_construct (GType object_type) {
	Mahjongg * self = NULL;
	self = (Mahjongg*) g_object_new (object_type, "application-id", "org.gnome.gnome-mahjongg", "flags", G_APPLICATION_FLAGS_NONE, NULL);
	g_action_map_add_action_entries ((GActionMap*) self, MAHJONGG_action_entries, G_N_ELEMENTS (MAHJONGG_action_entries), self);
	gtk_application_add_accelerator ((GtkApplication*) self, "Pause", "app.pause", NULL);
	gtk_application_add_accelerator ((GtkApplication*) self, "<Primary>h", "app.hint", NULL);
	gtk_application_add_accelerator ((GtkApplication*) self, "<Primary>z", "app.undo", NULL);
	gtk_application_add_accelerator ((GtkApplication*) self, "<Primary><Shift>z", "app.redo", NULL);
	return self;
}


Mahjongg* mahjongg_new (void) {
	return mahjongg_construct (TYPE_MAHJONGG);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean _mahjongg_window_configure_event_cb_gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = mahjongg_window_configure_event_cb (self, event);
	return result;
}


static gboolean _mahjongg_window_state_event_cb_gtk_widget_window_state_event (GtkWidget* _sender, GdkEventWindowState* event, gpointer self) {
	gboolean result;
	result = mahjongg_window_state_event_cb (self, event);
	return result;
}


static gboolean _mahjongg_view_button_press_event_gtk_widget_button_press_event (GtkWidget* _sender, GdkEventButton* event, gpointer self) {
	gboolean result;
	result = mahjongg_view_button_press_event (self, _sender, event);
	return result;
}


static void _mahjongg_conf_value_changed_cb_g_settings_changed (GSettings* _sender, const gchar* key, gpointer self) {
	mahjongg_conf_value_changed_cb (self, _sender, key);
}


static void mahjongg_real_startup (GApplication* base) {
	Mahjongg * self;
	GSettings* _tmp0_ = NULL;
	GtkBuilder* builder = NULL;
	GtkBuilder* _tmp1_ = NULL;
	GMenuModel* app_menu = NULL;
	GObject* _tmp3_ = NULL;
	GMenuModel* _tmp4_ = NULL;
	GMenuModel* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	History* _tmp9_ = NULL;
	History* _tmp10_ = NULL;
	GtkApplicationWindow* _tmp11_ = NULL;
	GtkApplicationWindow* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	GtkApplicationWindow* _tmp14_ = NULL;
	GtkApplicationWindow* _tmp15_ = NULL;
	GtkApplicationWindow* _tmp16_ = NULL;
	GSettings* _tmp17_ = NULL;
	gint _tmp18_ = 0;
	GSettings* _tmp19_ = NULL;
	gint _tmp20_ = 0;
	GSettings* _tmp21_ = NULL;
	gboolean _tmp22_ = FALSE;
	GtkBox* status_box = NULL;
	GtkBox* _tmp27_ = NULL;
	GtkBox* group_box = NULL;
	GtkBox* _tmp28_ = NULL;
	GtkLabel* label = NULL;
	const gchar* _tmp29_ = NULL;
	GtkLabel* _tmp30_ = NULL;
	GtkLabel* spacer = NULL;
	GtkLabel* _tmp31_ = NULL;
	GtkLabel* _tmp32_ = NULL;
	GtkLabel* _tmp33_ = NULL;
	GtkLabel* _tmp34_ = NULL;
	GtkLabel* _tmp35_ = NULL;
	GtkBox* vbox = NULL;
	GtkBox* _tmp36_ = NULL;
	GameView* _tmp37_ = NULL;
	GameView* _tmp38_ = NULL;
	GameView* _tmp39_ = NULL;
	GameView* _tmp40_ = NULL;
	GSettings* _tmp41_ = NULL;
	gboolean _tmp42_ = FALSE;
	GtkToolbar* toolbar = NULL;
	GtkToolbar* _tmp43_ = NULL;
	GtkStyleContext* _tmp44_ = NULL;
	GtkToolButton* new_game_button = NULL;
	const gchar* _tmp45_ = NULL;
	GtkToolButton* _tmp46_ = NULL;
	GtkToolButton* undo_button = NULL;
	const gchar* _tmp47_ = NULL;
	GtkToolButton* _tmp48_ = NULL;
	GtkToolButton* redo_button = NULL;
	const gchar* _tmp49_ = NULL;
	GtkToolButton* _tmp50_ = NULL;
	GtkToolButton* hint_button = NULL;
	const gchar* _tmp51_ = NULL;
	GtkToolButton* _tmp52_ = NULL;
	const gchar* _tmp53_ = NULL;
	GtkToolButton* _tmp54_ = NULL;
	GtkToolButton* _tmp55_ = NULL;
	GtkToolButton* _tmp56_ = NULL;
	GtkToolButton* _tmp57_ = NULL;
	GtkToolButton* _tmp58_ = NULL;
	GtkToolButton* _tmp59_ = NULL;
	GtkToolButton* _tmp60_ = NULL;
	GtkAlignment* status_alignment = NULL;
	GtkAlignment* _tmp61_ = NULL;
	GtkToolItem* _tmp62_ = NULL;
	GtkToolItem* _tmp63_ = NULL;
	GtkToolItem* _tmp64_ = NULL;
	GtkToolItem* _tmp65_ = NULL;
	GameView* _tmp66_ = NULL;
	GtkApplicationWindow* _tmp67_ = NULL;
	GSettings* _tmp68_ = NULL;
	GameView* _tmp69_ = NULL;
	GSettings* _tmp70_ = NULL;
	GSettings* _tmp71_ = NULL;
	GError * _inner_error_ = NULL;
	self = (Mahjongg*) base;
	G_APPLICATION_CLASS (mahjongg_parent_class)->startup ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, GTK_TYPE_APPLICATION, GtkApplication));
	_tmp0_ = g_settings_new ("org.gnome.gnome-mahjongg");
	_g_object_unref0 (self->priv->settings);
	self->priv->settings = _tmp0_;
	_tmp1_ = gtk_builder_new ();
	builder = _tmp1_;
	{
		gtk_builder_add_from_resource (builder, "/org/gnome/mahjongg/ui/menu.ui", &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp2_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = e->message;
		g_error ("gnome-mahjongg.vala:53: loading menu builder file: %s", _tmp2_);
		_g_error_free0 (e);
	}
	__finally3:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (builder);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp3_ = gtk_builder_get_object (builder, "appmenu");
	_tmp4_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, g_menu_model_get_type ()) ? ((GMenuModel*) _tmp3_) : NULL);
	app_menu = _tmp4_;
	_tmp5_ = app_menu;
	gtk_application_set_app_menu ((GtkApplication*) self, _tmp5_);
	mahjongg_load_maps (self);
	_tmp6_ = g_get_user_data_dir ();
	_tmp7_ = g_build_filename (_tmp6_, "gnome-mahjongg", "history", NULL);
	_tmp8_ = _tmp7_;
	_tmp9_ = history_new (_tmp8_);
	_history_unref0 (self->priv->history);
	self->priv->history = _tmp9_;
	_g_free0 (_tmp8_);
	_tmp10_ = self->priv->history;
	history_load (_tmp10_);
	_tmp11_ = (GtkApplicationWindow*) gtk_application_window_new ((GtkApplication*) self);
	g_object_ref_sink (_tmp11_);
	_g_object_unref0 (self->priv->window);
	self->priv->window = _tmp11_;
	_tmp12_ = self->priv->window;
	_tmp13_ = _ ("Mahjongg");
	gtk_window_set_title ((GtkWindow*) _tmp12_, _tmp13_);
	_tmp14_ = self->priv->window;
	g_signal_connect_object ((GtkWidget*) _tmp14_, "configure-event", (GCallback) _mahjongg_window_configure_event_cb_gtk_widget_configure_event, self, 0);
	_tmp15_ = self->priv->window;
	g_signal_connect_object ((GtkWidget*) _tmp15_, "window-state-event", (GCallback) _mahjongg_window_state_event_cb_gtk_widget_window_state_event, self, 0);
	_tmp16_ = self->priv->window;
	_tmp17_ = self->priv->settings;
	_tmp18_ = g_settings_get_int (_tmp17_, "window-width");
	_tmp19_ = self->priv->settings;
	_tmp20_ = g_settings_get_int (_tmp19_, "window-height");
	gtk_window_set_default_size ((GtkWindow*) _tmp16_, _tmp18_, _tmp20_);
	_tmp21_ = self->priv->settings;
	_tmp22_ = g_settings_get_boolean (_tmp21_, "window-is-fullscreen");
	if (_tmp22_) {
		GtkApplicationWindow* _tmp23_ = NULL;
		_tmp23_ = self->priv->window;
		gtk_window_fullscreen ((GtkWindow*) _tmp23_);
	} else {
		GSettings* _tmp24_ = NULL;
		gboolean _tmp25_ = FALSE;
		_tmp24_ = self->priv->settings;
		_tmp25_ = g_settings_get_boolean (_tmp24_, "window-is-maximized");
		if (_tmp25_) {
			GtkApplicationWindow* _tmp26_ = NULL;
			_tmp26_ = self->priv->window;
			gtk_window_maximize ((GtkWindow*) _tmp26_);
		}
	}
	_tmp27_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 10);
	g_object_ref_sink (_tmp27_);
	status_box = _tmp27_;
	_tmp28_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp28_);
	group_box = _tmp28_;
	_tmp29_ = _ ("Moves Left:");
	_tmp30_ = (GtkLabel*) gtk_label_new (_tmp29_);
	g_object_ref_sink (_tmp30_);
	label = _tmp30_;
	gtk_box_pack_start (group_box, (GtkWidget*) label, FALSE, FALSE, (guint) 0);
	_tmp31_ = (GtkLabel*) gtk_label_new (" ");
	g_object_ref_sink (_tmp31_);
	spacer = _tmp31_;
	gtk_box_pack_start (group_box, (GtkWidget*) spacer, FALSE, FALSE, (guint) 0);
	_tmp32_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp32_);
	_g_object_unref0 (self->priv->moves_label);
	self->priv->moves_label = _tmp32_;
	_tmp33_ = self->priv->moves_label;
	gtk_box_pack_start (group_box, (GtkWidget*) _tmp33_, FALSE, FALSE, (guint) 0);
	gtk_box_pack_start (status_box, (GtkWidget*) group_box, FALSE, FALSE, (guint) 0);
	_tmp34_ = (GtkLabel*) gtk_label_new ("");
	g_object_ref_sink (_tmp34_);
	_g_object_unref0 (self->priv->clock_label);
	self->priv->clock_label = _tmp34_;
	_tmp35_ = self->priv->clock_label;
	gtk_box_pack_start (status_box, (GtkWidget*) _tmp35_, FALSE, FALSE, (guint) 0);
	_tmp36_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp36_);
	vbox = _tmp36_;
	_tmp37_ = game_view_new ();
	g_object_ref_sink (_tmp37_);
	_g_object_unref0 (self->priv->game_view);
	self->priv->game_view = _tmp37_;
	_tmp38_ = self->priv->game_view;
	g_signal_connect_object ((GtkWidget*) _tmp38_, "button-press-event", (GCallback) _mahjongg_view_button_press_event_gtk_widget_button_press_event, self, 0);
	_tmp39_ = self->priv->game_view;
	gtk_widget_set_size_request ((GtkWidget*) _tmp39_, 600, 400);
	_tmp40_ = self->priv->game_view;
	_tmp41_ = self->priv->settings;
	_tmp42_ = g_settings_get_boolean (_tmp41_, "autoplay");
	_tmp40_->auto_play = _tmp42_;
	_tmp43_ = (GtkToolbar*) gtk_toolbar_new ();
	g_object_ref_sink (_tmp43_);
	toolbar = _tmp43_;
	gtk_toolbar_set_show_arrow (toolbar, FALSE);
	_tmp44_ = gtk_widget_get_style_context ((GtkWidget*) toolbar);
	gtk_style_context_add_class (_tmp44_, GTK_STYLE_CLASS_PRIMARY_TOOLBAR);
	_tmp45_ = _ ("_New");
	_tmp46_ = (GtkToolButton*) gtk_tool_button_new (NULL, _tmp45_);
	g_object_ref_sink (_tmp46_);
	new_game_button = _tmp46_;
	gtk_tool_button_set_use_underline (new_game_button, TRUE);
	gtk_tool_button_set_icon_name (new_game_button, "document-new");
	gtk_actionable_set_action_name ((GtkActionable*) new_game_button, "app.new-game");
	gtk_widget_show ((GtkWidget*) new_game_button);
	gtk_toolbar_insert (toolbar, (GtkToolItem*) new_game_button, -1);
	_tmp47_ = _ ("_Undo Move");
	_tmp48_ = (GtkToolButton*) gtk_tool_button_new (NULL, _tmp47_);
	g_object_ref_sink (_tmp48_);
	undo_button = _tmp48_;
	gtk_tool_button_set_use_underline (undo_button, TRUE);
	gtk_tool_button_set_icon_name (undo_button, "edit-undo");
	gtk_actionable_set_action_name ((GtkActionable*) undo_button, "app.undo");
	gtk_tool_item_set_is_important ((GtkToolItem*) undo_button, TRUE);
	gtk_widget_show ((GtkWidget*) undo_button);
	gtk_toolbar_insert (toolbar, (GtkToolItem*) undo_button, -1);
	_tmp49_ = _ ("_Redo Move");
	_tmp50_ = (GtkToolButton*) gtk_tool_button_new (NULL, _tmp49_);
	g_object_ref_sink (_tmp50_);
	redo_button = _tmp50_;
	gtk_tool_button_set_use_underline (redo_button, TRUE);
	gtk_tool_button_set_icon_name (redo_button, "edit-redo");
	gtk_actionable_set_action_name ((GtkActionable*) redo_button, "app.redo");
	gtk_tool_item_set_is_important ((GtkToolItem*) redo_button, TRUE);
	gtk_widget_show ((GtkWidget*) redo_button);
	gtk_toolbar_insert (toolbar, (GtkToolItem*) redo_button, -1);
	_tmp51_ = _ ("Hint");
	_tmp52_ = (GtkToolButton*) gtk_tool_button_new (NULL, _tmp51_);
	g_object_ref_sink (_tmp52_);
	hint_button = _tmp52_;
	gtk_tool_button_set_use_underline (hint_button, TRUE);
	gtk_tool_button_set_icon_name (hint_button, "dialog-information");
	gtk_actionable_set_action_name ((GtkActionable*) hint_button, "app.hint");
	gtk_tool_item_set_is_important ((GtkToolItem*) hint_button, TRUE);
	gtk_widget_show ((GtkWidget*) hint_button);
	gtk_toolbar_insert (toolbar, (GtkToolItem*) hint_button, -1);
	_tmp53_ = _ ("_Pause");
	_tmp54_ = (GtkToolButton*) gtk_tool_button_new (NULL, _tmp53_);
	g_object_ref_sink (_tmp54_);
	_g_object_unref0 (self->priv->pause_button);
	self->priv->pause_button = _tmp54_;
	_tmp55_ = self->priv->pause_button;
	gtk_tool_button_set_icon_name (_tmp55_, "media-playback-pause");
	_tmp56_ = self->priv->pause_button;
	gtk_tool_button_set_use_underline (_tmp56_, TRUE);
	_tmp57_ = self->priv->pause_button;
	gtk_actionable_set_action_name ((GtkActionable*) _tmp57_, "app.pause");
	_tmp58_ = self->priv->pause_button;
	gtk_tool_item_set_is_important ((GtkToolItem*) _tmp58_, TRUE);
	_tmp59_ = self->priv->pause_button;
	gtk_widget_show ((GtkWidget*) _tmp59_);
	_tmp60_ = self->priv->pause_button;
	gtk_toolbar_insert (toolbar, (GtkToolItem*) _tmp60_, -1);
	_tmp61_ = (GtkAlignment*) gtk_alignment_new (1.0f, 0.5f, 0.0f, 0.0f);
	g_object_ref_sink (_tmp61_);
	status_alignment = _tmp61_;
	gtk_container_add ((GtkContainer*) status_alignment, (GtkWidget*) status_box);
	_tmp62_ = gtk_tool_item_new ();
	g_object_ref_sink (_tmp62_);
	_g_object_unref0 (self->priv->status_item);
	self->priv->status_item = _tmp62_;
	_tmp63_ = self->priv->status_item;
	gtk_tool_item_set_expand (_tmp63_, TRUE);
	_tmp64_ = self->priv->status_item;
	gtk_container_add ((GtkContainer*) _tmp64_, (GtkWidget*) status_alignment);
	_tmp65_ = self->priv->status_item;
	gtk_toolbar_insert (toolbar, _tmp65_, -1);
	gtk_box_pack_start (vbox, (GtkWidget*) toolbar, FALSE, FALSE, (guint) 0);
	_tmp66_ = self->priv->game_view;
	gtk_box_pack_start (vbox, (GtkWidget*) _tmp66_, TRUE, TRUE, (guint) 0);
	_tmp67_ = self->priv->window;
	gtk_container_add ((GtkContainer*) _tmp67_, (GtkWidget*) vbox);
	gtk_widget_show_all ((GtkWidget*) vbox);
	_tmp68_ = self->priv->settings;
	g_signal_connect_object (_tmp68_, "changed", (GCallback) _mahjongg_conf_value_changed_cb_g_settings_changed, self, 0);
	mahjongg_new_game (self);
	_tmp69_ = self->priv->game_view;
	gtk_widget_grab_focus ((GtkWidget*) _tmp69_);
	_tmp70_ = self->priv->settings;
	mahjongg_conf_value_changed_cb (self, _tmp70_, "tileset");
	_tmp71_ = self->priv->settings;
	mahjongg_conf_value_changed_cb (self, _tmp71_, "bgcolour");
	mahjongg_tick_cb (self);
	_g_object_unref0 (status_alignment);
	_g_object_unref0 (hint_button);
	_g_object_unref0 (redo_button);
	_g_object_unref0 (undo_button);
	_g_object_unref0 (new_game_button);
	_g_object_unref0 (toolbar);
	_g_object_unref0 (vbox);
	_g_object_unref0 (spacer);
	_g_object_unref0 (label);
	_g_object_unref0 (group_box);
	_g_object_unref0 (status_box);
	_g_object_unref0 (app_menu);
	_g_object_unref0 (builder);
}


static gboolean mahjongg_window_configure_event_cb (Mahjongg* self, GdkEventConfigure* event) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp3_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp1_ = self->priv->is_maximized;
	if (!_tmp1_) {
		gboolean _tmp2_ = FALSE;
		_tmp2_ = self->priv->is_fullscreen;
		_tmp0_ = !_tmp2_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp3_ = _tmp0_;
	if (_tmp3_) {
		GdkEventConfigure _tmp4_ = {0};
		gint _tmp5_ = 0;
		GdkEventConfigure _tmp6_ = {0};
		gint _tmp7_ = 0;
		_tmp4_ = *event;
		_tmp5_ = _tmp4_.width;
		self->priv->window_width = _tmp5_;
		_tmp6_ = *event;
		_tmp7_ = _tmp6_.height;
		self->priv->window_height = _tmp7_;
	}
	result = FALSE;
	return result;
}


static gboolean mahjongg_window_state_event_cb (Mahjongg* self, GdkEventWindowState* event) {
	gboolean result = FALSE;
	GdkEventWindowState _tmp0_ = {0};
	GdkWindowState _tmp1_ = 0;
	GdkEventWindowState _tmp4_ = {0};
	GdkWindowState _tmp5_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = *event;
	_tmp1_ = _tmp0_.changed_mask;
	if ((_tmp1_ & GDK_WINDOW_STATE_MAXIMIZED) != 0) {
		GdkEventWindowState _tmp2_ = {0};
		GdkWindowState _tmp3_ = 0;
		_tmp2_ = *event;
		_tmp3_ = _tmp2_.new_window_state;
		self->priv->is_maximized = (_tmp3_ & GDK_WINDOW_STATE_MAXIMIZED) != 0;
	}
	_tmp4_ = *event;
	_tmp5_ = _tmp4_.changed_mask;
	if ((_tmp5_ & GDK_WINDOW_STATE_FULLSCREEN) != 0) {
		GdkEventWindowState _tmp6_ = {0};
		GdkWindowState _tmp7_ = 0;
		_tmp6_ = *event;
		_tmp7_ = _tmp6_.new_window_state;
		self->priv->is_fullscreen = (_tmp7_ & GDK_WINDOW_STATE_FULLSCREEN) != 0;
	}
	result = FALSE;
	return result;
}


static void mahjongg_real_shutdown (GApplication* base) {
	Mahjongg * self;
	GSettings* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	GSettings* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	GSettings* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	GSettings* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	self = (Mahjongg*) base;
	G_APPLICATION_CLASS (mahjongg_parent_class)->shutdown ((GApplication*) G_TYPE_CHECK_INSTANCE_CAST (self, GTK_TYPE_APPLICATION, GtkApplication));
	_tmp0_ = self->priv->settings;
	_tmp1_ = self->priv->window_width;
	g_settings_set_int (_tmp0_, "window-width", _tmp1_);
	_tmp2_ = self->priv->settings;
	_tmp3_ = self->priv->window_height;
	g_settings_set_int (_tmp2_, "window-height", _tmp3_);
	_tmp4_ = self->priv->settings;
	_tmp5_ = self->priv->is_maximized;
	g_settings_set_boolean (_tmp4_, "window-is-maximized", _tmp5_);
	_tmp6_ = self->priv->settings;
	_tmp7_ = self->priv->is_fullscreen;
	g_settings_set_boolean (_tmp6_, "window-is-fullscreen", _tmp7_);
}


static void mahjongg_real_activate (GApplication* base) {
	Mahjongg * self;
	GtkApplicationWindow* _tmp0_ = NULL;
	self = (Mahjongg*) base;
	_tmp0_ = self->priv->window;
	gtk_window_present ((GtkWindow*) _tmp0_);
}


static void mahjongg_update_ui (Mahjongg* self) {
	GSimpleAction* pause_action = NULL;
	GAction* _tmp0_ = NULL;
	GSimpleAction* _tmp1_ = NULL;
	GSimpleAction* hint_action = NULL;
	GAction* _tmp2_ = NULL;
	GSimpleAction* _tmp3_ = NULL;
	GSimpleAction* undo_action = NULL;
	GAction* _tmp4_ = NULL;
	GSimpleAction* _tmp5_ = NULL;
	GSimpleAction* redo_action = NULL;
	GAction* _tmp6_ = NULL;
	GSimpleAction* _tmp7_ = NULL;
	GSimpleAction* _tmp8_ = NULL;
	GameView* _tmp9_ = NULL;
	Game* _tmp10_ = NULL;
	Game* _tmp11_ = NULL;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	GameView* _tmp14_ = NULL;
	Game* _tmp15_ = NULL;
	Game* _tmp16_ = NULL;
	gboolean _tmp17_ = FALSE;
	gboolean _tmp18_ = FALSE;
	GtkLabel* _tmp40_ = NULL;
	GameView* _tmp41_ = NULL;
	Game* _tmp42_ = NULL;
	Game* _tmp43_ = NULL;
	guint _tmp44_ = 0U;
	guint _tmp45_ = 0U;
	gchar* _tmp46_ = NULL;
	gchar* _tmp47_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_action_map_lookup_action ((GActionMap*) self, "pause");
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp0_) : NULL);
	pause_action = _tmp1_;
	_tmp2_ = g_action_map_lookup_action ((GActionMap*) self, "hint");
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp2_) : NULL);
	hint_action = _tmp3_;
	_tmp4_ = g_action_map_lookup_action ((GActionMap*) self, "undo");
	_tmp5_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp4_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp4_) : NULL);
	undo_action = _tmp5_;
	_tmp6_ = g_action_map_lookup_action ((GActionMap*) self, "redo");
	_tmp7_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp6_, g_simple_action_get_type ()) ? ((GSimpleAction*) _tmp6_) : NULL);
	redo_action = _tmp7_;
	_tmp8_ = pause_action;
	_tmp9_ = self->priv->game_view;
	_tmp10_ = game_view_get_game (_tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = game_get_started (_tmp11_);
	_tmp13_ = _tmp12_;
	g_simple_action_set_enabled (_tmp8_, _tmp13_);
	_tmp14_ = self->priv->game_view;
	_tmp15_ = game_view_get_game (_tmp14_);
	_tmp16_ = _tmp15_;
	_tmp17_ = game_get_paused (_tmp16_);
	_tmp18_ = _tmp17_;
	if (_tmp18_) {
		GSimpleAction* _tmp19_ = NULL;
		GSimpleAction* _tmp20_ = NULL;
		GSimpleAction* _tmp21_ = NULL;
		_tmp19_ = hint_action;
		g_simple_action_set_enabled (_tmp19_, FALSE);
		_tmp20_ = undo_action;
		g_simple_action_set_enabled (_tmp20_, FALSE);
		_tmp21_ = redo_action;
		g_simple_action_set_enabled (_tmp21_, FALSE);
	} else {
		GSimpleAction* _tmp22_ = NULL;
		GameView* _tmp23_ = NULL;
		Game* _tmp24_ = NULL;
		Game* _tmp25_ = NULL;
		guint _tmp26_ = 0U;
		guint _tmp27_ = 0U;
		GSimpleAction* _tmp28_ = NULL;
		GameView* _tmp29_ = NULL;
		Game* _tmp30_ = NULL;
		Game* _tmp31_ = NULL;
		gboolean _tmp32_ = FALSE;
		gboolean _tmp33_ = FALSE;
		GSimpleAction* _tmp34_ = NULL;
		GameView* _tmp35_ = NULL;
		Game* _tmp36_ = NULL;
		Game* _tmp37_ = NULL;
		gboolean _tmp38_ = FALSE;
		gboolean _tmp39_ = FALSE;
		_tmp22_ = hint_action;
		_tmp23_ = self->priv->game_view;
		_tmp24_ = game_view_get_game (_tmp23_);
		_tmp25_ = _tmp24_;
		_tmp26_ = game_get_moves_left (_tmp25_);
		_tmp27_ = _tmp26_;
		g_simple_action_set_enabled (_tmp22_, _tmp27_ > ((guint) 0));
		_tmp28_ = undo_action;
		_tmp29_ = self->priv->game_view;
		_tmp30_ = game_view_get_game (_tmp29_);
		_tmp31_ = _tmp30_;
		_tmp32_ = game_get_can_undo (_tmp31_);
		_tmp33_ = _tmp32_;
		g_simple_action_set_enabled (_tmp28_, _tmp33_);
		_tmp34_ = redo_action;
		_tmp35_ = self->priv->game_view;
		_tmp36_ = game_view_get_game (_tmp35_);
		_tmp37_ = _tmp36_;
		_tmp38_ = game_get_can_redo (_tmp37_);
		_tmp39_ = _tmp38_;
		g_simple_action_set_enabled (_tmp34_, _tmp39_);
	}
	_tmp40_ = self->priv->moves_label;
	_tmp41_ = self->priv->game_view;
	_tmp42_ = game_view_get_game (_tmp41_);
	_tmp43_ = _tmp42_;
	_tmp44_ = game_get_moves_left (_tmp43_);
	_tmp45_ = _tmp44_;
	_tmp46_ = g_strdup_printf ("%2u", _tmp45_);
	_tmp47_ = _tmp46_;
	gtk_label_set_text (_tmp40_, _tmp47_);
	_g_free0 (_tmp47_);
	_g_object_unref0 (redo_action);
	_g_object_unref0 (undo_action);
	_g_object_unref0 (hint_action);
	_g_object_unref0 (pause_action);
}


static void mahjongg_theme_changed_cb (Mahjongg* self, GtkComboBox* widget) {
	GtkTreeIter iter = {0};
	GtkComboBox* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	gchar* theme = NULL;
	GtkComboBox* _tmp2_ = NULL;
	GtkTreeModel* _tmp3_ = NULL;
	GtkTreeModel* _tmp4_ = NULL;
	GtkTreeIter _tmp5_ = {0};
	GSettings* _tmp6_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_tmp0_ = widget;
	gtk_combo_box_get_active_iter (_tmp0_, &_tmp1_);
	iter = _tmp1_;
	_tmp2_ = widget;
	_tmp3_ = gtk_combo_box_get_model (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = iter;
	gtk_tree_model_get (_tmp4_, &_tmp5_, 1, &theme, -1);
	_tmp6_ = self->priv->settings;
	g_settings_set_string (_tmp6_, "tileset", theme);
	_g_free0 (theme);
}


static void mahjongg_conf_value_changed_cb (Mahjongg* self, GSettings* settings, const gchar* key) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (settings != NULL);
	g_return_if_fail (key != NULL);
	_tmp0_ = key;
	if (g_strcmp0 (_tmp0_, "tileset") == 0) {
		gchar* theme = NULL;
		GSettings* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GameView* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp1_ = settings;
		_tmp2_ = g_settings_get_string (_tmp1_, "tileset");
		theme = _tmp2_;
		_tmp3_ = self->priv->game_view;
		_tmp4_ = theme;
		_tmp5_ = g_build_filename (DATA_DIRECTORY, "themes", _tmp4_, NULL);
		_tmp6_ = _tmp5_;
		game_view_set_theme (_tmp3_, _tmp6_);
		_g_free0 (_tmp6_);
		_g_free0 (theme);
	} else {
		const gchar* _tmp7_ = NULL;
		_tmp7_ = key;
		if (g_strcmp0 (_tmp7_, "bgcolour") == 0) {
			GameView* _tmp8_ = NULL;
			GSettings* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			_tmp8_ = self->priv->game_view;
			_tmp9_ = settings;
			_tmp10_ = g_settings_get_string (_tmp9_, "bgcolour");
			_tmp11_ = _tmp10_;
			game_view_set_background (_tmp8_, _tmp11_);
			_g_free0 (_tmp11_);
		} else {
			const gchar* _tmp12_ = NULL;
			_tmp12_ = key;
			if (g_strcmp0 (_tmp12_, "mapset") == 0) {
				GameView* _tmp13_ = NULL;
				Game* _tmp14_ = NULL;
				Game* _tmp15_ = NULL;
				gboolean _tmp16_ = FALSE;
				gboolean _tmp17_ = FALSE;
				_tmp13_ = self->priv->game_view;
				_tmp14_ = game_view_get_game (_tmp13_);
				_tmp15_ = _tmp14_;
				_tmp16_ = game_get_started (_tmp15_);
				_tmp17_ = _tmp16_;
				if (_tmp17_) {
					GtkMessageDialog* dialog = NULL;
					GtkApplicationWindow* _tmp18_ = NULL;
					const gchar* _tmp19_ = NULL;
					GtkMessageDialog* _tmp20_ = NULL;
					GtkMessageDialog* _tmp21_ = NULL;
					const gchar* _tmp22_ = NULL;
					GtkMessageDialog* _tmp23_ = NULL;
					const gchar* _tmp24_ = NULL;
					const gchar* _tmp25_ = NULL;
					GtkMessageDialog* _tmp26_ = NULL;
					gint response = 0;
					GtkMessageDialog* _tmp27_ = NULL;
					gint _tmp28_ = 0;
					gint _tmp29_ = 0;
					GtkMessageDialog* _tmp30_ = NULL;
					_tmp18_ = self->priv->window;
					_tmp19_ = _ ("Do you want to start a new game with this map?");
					_tmp20_ = (GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) _tmp18_, GTK_DIALOG_MODAL, GTK_MESSAGE_QUESTION, GTK_BUTTONS_NONE, "%s", _tmp19_);
					g_object_ref_sink (_tmp20_);
					dialog = _tmp20_;
					_tmp21_ = dialog;
					_tmp22_ = _ ("If you continue playing the next game will use the new map.");
					gtk_message_dialog_format_secondary_text (_tmp21_, "%s", _tmp22_);
					_tmp23_ = dialog;
					_tmp24_ = _ ("_Continue playing");
					_tmp25_ = _ ("Use _new map");
					gtk_dialog_add_buttons ((GtkDialog*) _tmp23_, _tmp24_, GTK_RESPONSE_REJECT, _tmp25_, GTK_RESPONSE_ACCEPT, NULL, NULL);
					_tmp26_ = dialog;
					gtk_dialog_set_default_response ((GtkDialog*) _tmp26_, (gint) GTK_RESPONSE_ACCEPT);
					_tmp27_ = dialog;
					_tmp28_ = gtk_dialog_run ((GtkDialog*) _tmp27_);
					response = _tmp28_;
					_tmp29_ = response;
					if (_tmp29_ == ((gint) GTK_RESPONSE_ACCEPT)) {
						mahjongg_new_game (self);
					}
					_tmp30_ = dialog;
					gtk_widget_destroy ((GtkWidget*) _tmp30_);
					_g_object_unref0 (dialog);
				} else {
					mahjongg_new_game (self);
				}
			}
		}
	}
}


static gboolean mahjongg_view_button_press_event (Mahjongg* self, GtkWidget* widget, GdkEventButton* event) {
	gboolean result = FALSE;
	GameView* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (widget != NULL, FALSE);
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp0_ = self->priv->game_view;
	_tmp1_ = game_view_get_game (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = game_get_paused (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_) {
		GameView* _tmp5_ = NULL;
		Game* _tmp6_ = NULL;
		Game* _tmp7_ = NULL;
		_tmp5_ = self->priv->game_view;
		_tmp6_ = game_view_get_game (_tmp5_);
		_tmp7_ = _tmp6_;
		game_set_paused (_tmp7_, FALSE);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static void mahjongg_background_changed_cb (Mahjongg* self, GtkColorButton* widget) {
	GdkRGBA colour = {0};
	GtkColorButton* _tmp0_ = NULL;
	GdkRGBA _tmp1_ = {0};
	GSettings* _tmp2_ = NULL;
	GdkRGBA _tmp3_ = {0};
	gdouble _tmp4_ = 0.0;
	GdkRGBA _tmp5_ = {0};
	gdouble _tmp6_ = 0.0;
	GdkRGBA _tmp7_ = {0};
	gdouble _tmp8_ = 0.0;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_tmp0_ = widget;
	gtk_color_button_get_rgba (_tmp0_, &_tmp1_);
	colour = _tmp1_;
	_tmp2_ = self->priv->settings;
	_tmp3_ = colour;
	_tmp4_ = _tmp3_.red;
	_tmp5_ = colour;
	_tmp6_ = _tmp5_.green;
	_tmp7_ = colour;
	_tmp8_ = _tmp7_.blue;
	_tmp9_ = g_strdup_printf ("#%04x%04x%04x", (guint) ((gint) ((_tmp4_ * 65536) + 0.5)), (guint) ((gint) ((_tmp6_ * 65536) + 0.5)), (guint) ((gint) ((_tmp8_ * 65536) + 0.5)));
	_tmp10_ = _tmp9_;
	g_settings_set_string (_tmp2_, "bgcolour", _tmp10_);
	_g_free0 (_tmp10_);
}


static void mahjongg_map_changed_cb (Mahjongg* self, GtkComboBox* widget) {
	GSettings* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	GtkComboBox* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gconstpointer _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_tmp0_ = self->priv->settings;
	_tmp1_ = self->priv->maps;
	_tmp2_ = widget;
	_tmp3_ = gtk_combo_box_get_active (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_list_nth_data (_tmp1_, (guint) _tmp4_);
	_tmp6_ = ((Map*) _tmp5_)->name;
	g_settings_set_string (_tmp0_, "mapset", _tmp6_);
}


static void mahjongg_toggle_auto_play_cb (Mahjongg* self, GtkToggleButton* widget) {
	gboolean on_or_off = FALSE;
	GtkToggleButton* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	GSettings* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	GameView* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	GameView* _tmp6_ = NULL;
	Game* _tmp7_ = NULL;
	Game* _tmp8_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_tmp0_ = widget;
	_tmp1_ = gtk_toggle_button_get_active (_tmp0_);
	on_or_off = _tmp1_;
	_tmp2_ = self->priv->settings;
	_tmp3_ = on_or_off;
	g_settings_set_boolean (_tmp2_, "autoplay", _tmp3_);
	_tmp4_ = self->priv->game_view;
	_tmp5_ = on_or_off;
	_tmp4_->auto_play = _tmp5_;
	_tmp6_ = self->priv->game_view;
	_tmp7_ = game_view_get_game (_tmp6_);
	_tmp8_ = _tmp7_;
	if (_tmp8_ != NULL) {
		GameView* _tmp9_ = NULL;
		Game* _tmp10_ = NULL;
		Game* _tmp11_ = NULL;
		_tmp9_ = self->priv->game_view;
		_tmp10_ = game_view_get_game (_tmp9_);
		_tmp11_ = _tmp10_;
		game_auto_move (_tmp11_);
	}
}


static void mahjongg_moved_cb (Mahjongg* self) {
	GameView* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	mahjongg_update_ui (self);
	_tmp0_ = self->priv->game_view;
	_tmp1_ = game_view_get_game (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = game_get_complete (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_) {
		GDateTime* date = NULL;
		GDateTime* _tmp5_ = NULL;
		guint duration = 0U;
		GameView* _tmp6_ = NULL;
		Game* _tmp7_ = NULL;
		Game* _tmp8_ = NULL;
		gdouble _tmp9_ = 0.0;
		gdouble _tmp10_ = 0.0;
		HistoryEntry* entry = NULL;
		GDateTime* _tmp11_ = NULL;
		GameView* _tmp12_ = NULL;
		Game* _tmp13_ = NULL;
		Game* _tmp14_ = NULL;
		Map* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		guint _tmp17_ = 0U;
		HistoryEntry* _tmp18_ = NULL;
		History* _tmp19_ = NULL;
		HistoryEntry* _tmp20_ = NULL;
		History* _tmp21_ = NULL;
		HistoryEntry* _tmp22_ = NULL;
		gint _tmp23_ = 0;
		_tmp5_ = g_date_time_new_now_local ();
		date = _tmp5_;
		_tmp6_ = self->priv->game_view;
		_tmp7_ = game_view_get_game (_tmp6_);
		_tmp8_ = _tmp7_;
		_tmp9_ = game_get_elapsed (_tmp8_);
		_tmp10_ = _tmp9_;
		duration = (guint) (_tmp10_ + 0.5);
		_tmp11_ = date;
		_tmp12_ = self->priv->game_view;
		_tmp13_ = game_view_get_game (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = _tmp14_->map;
		_tmp16_ = _tmp15_->score_name;
		_tmp17_ = duration;
		_tmp18_ = history_entry_new (_tmp11_, _tmp16_, _tmp17_);
		entry = _tmp18_;
		_tmp19_ = self->priv->history;
		_tmp20_ = entry;
		history_add (_tmp19_, _tmp20_);
		_tmp21_ = self->priv->history;
		history_save (_tmp21_);
		_tmp22_ = entry;
		_tmp23_ = mahjongg_show_scores (self, _tmp22_, TRUE);
		if (_tmp23_ == ((gint) GTK_RESPONSE_CLOSE)) {
			GtkApplicationWindow* _tmp24_ = NULL;
			_tmp24_ = self->priv->window;
			gtk_widget_destroy ((GtkWidget*) _tmp24_);
		} else {
			mahjongg_new_game (self);
		}
		_history_entry_unref0 (entry);
		_g_date_time_unref0 (date);
	} else {
		GameView* _tmp25_ = NULL;
		Game* _tmp26_ = NULL;
		Game* _tmp27_ = NULL;
		gboolean _tmp28_ = FALSE;
		gboolean _tmp29_ = FALSE;
		_tmp25_ = self->priv->game_view;
		_tmp26_ = game_view_get_game (_tmp25_);
		_tmp27_ = _tmp26_;
		_tmp28_ = game_get_can_move (_tmp27_);
		_tmp29_ = _tmp28_;
		if (!_tmp29_) {
			GtkMessageDialog* dialog = NULL;
			GtkApplicationWindow* _tmp30_ = NULL;
			const gchar* _tmp31_ = NULL;
			GtkMessageDialog* _tmp32_ = NULL;
			GtkMessageDialog* _tmp33_ = NULL;
			const gchar* _tmp34_ = NULL;
			GtkMessageDialog* _tmp35_ = NULL;
			const gchar* _tmp36_ = NULL;
			const gchar* _tmp37_ = NULL;
			GtkMessageDialog* _tmp38_ = NULL;
			GtkMessageDialog* _tmp39_ = NULL;
			gint _tmp40_ = 0;
			GtkMessageDialog* _tmp41_ = NULL;
			_tmp30_ = self->priv->window;
			_tmp31_ = _ ("There are no more moves.");
			_tmp32_ = (GtkMessageDialog*) gtk_message_dialog_new ((GtkWindow*) _tmp30_, GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT, GTK_MESSAGE_INFO, GTK_BUTTONS_NONE, "%s", _tmp31_);
			g_object_ref_sink (_tmp32_);
			dialog = _tmp32_;
			_tmp33_ = dialog;
			_tmp34_ = _ ("Each puzzle has at least one solution.  You can undo your moves and tr" \
"y and find the solution for a time penalty, restart this game or start" \
" an new one.");
			gtk_message_dialog_format_secondary_text (_tmp33_, "%s", _tmp34_);
			_tmp35_ = dialog;
			_tmp36_ = _ ("_Restart");
			_tmp37_ = _ ("_New game");
			gtk_dialog_add_buttons ((GtkDialog*) _tmp35_, GTK_STOCK_UNDO, GTK_RESPONSE_REJECT, _tmp36_, GTK_RESPONSE_CANCEL, _tmp37_, GTK_RESPONSE_ACCEPT, NULL);
			_tmp38_ = dialog;
			gtk_dialog_set_default_response ((GtkDialog*) _tmp38_, (gint) GTK_RESPONSE_ACCEPT);
			_tmp39_ = dialog;
			_tmp40_ = gtk_dialog_run ((GtkDialog*) _tmp39_);
			switch (_tmp40_) {
				case GTK_RESPONSE_REJECT:
				{
					mahjongg_undo_cb (self);
					break;
				}
				case GTK_RESPONSE_CANCEL:
				{
					mahjongg_restart_game (self);
					break;
				}
				default:
				case GTK_RESPONSE_ACCEPT:
				{
					mahjongg_new_game (self);
					break;
				}
			}
			_tmp41_ = dialog;
			gtk_widget_destroy ((GtkWidget*) _tmp41_);
			_g_object_unref0 (dialog);
		}
	}
}


static gint mahjongg_show_scores (Mahjongg* self, HistoryEntry* selected_entry, gboolean show_quit) {
	gint result = 0;
	ScoreDialog* dialog = NULL;
	History* _tmp0_ = NULL;
	HistoryEntry* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	ScoreDialog* _tmp3_ = NULL;
	GtkApplicationWindow* _tmp4_ = NULL;
	gint _result_ = 0;
	gint _tmp5_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->history;
	_tmp1_ = selected_entry;
	_tmp2_ = show_quit;
	_tmp3_ = score_dialog_new (_tmp0_, _tmp1_, _tmp2_);
	g_object_ref_sink (_tmp3_);
	dialog = _tmp3_;
	gtk_window_set_modal ((GtkWindow*) dialog, TRUE);
	_tmp4_ = self->priv->window;
	gtk_window_set_transient_for ((GtkWindow*) dialog, (GtkWindow*) _tmp4_);
	_tmp5_ = gtk_dialog_run ((GtkDialog*) dialog);
	_result_ = _tmp5_;
	gtk_widget_destroy ((GtkWidget*) dialog);
	result = _result_;
	_g_object_unref0 (dialog);
	return result;
}


static void _mahjongg_preferences_dialog_response_cb_gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	mahjongg_preferences_dialog_response_cb (self, _sender, response_id);
}


static void _mahjongg_theme_changed_cb_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	mahjongg_theme_changed_cb (self, _sender);
}


static gpointer _map_ref0 (gpointer self) {
	return self ? map_ref (self) : NULL;
}


static void _mahjongg_map_changed_cb_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	mahjongg_map_changed_cb (self, _sender);
}


static void _mahjongg_background_changed_cb_gtk_color_button_color_set (GtkColorButton* _sender, gpointer self) {
	mahjongg_background_changed_cb (self, _sender);
}


static void _mahjongg_toggle_auto_play_cb_gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	mahjongg_toggle_auto_play_cb (self, _sender);
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_list_free__g_free0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_free0_, NULL);
	g_list_free (self);
}


static void mahjongg_preferences_cb (Mahjongg* self) {
	GtkDialog* _tmp0_ = NULL;
	const gchar* _tmp2_ = NULL;
	GtkApplicationWindow* _tmp3_ = NULL;
	GtkDialog* _tmp4_ = NULL;
	GtkDialog* _tmp5_ = NULL;
	GtkBox* dialog_content_area = NULL;
	GtkDialog* _tmp6_ = NULL;
	GtkBox* _tmp7_ = NULL;
	GtkBox* _tmp8_ = NULL;
	GtkBox* _tmp9_ = NULL;
	GtkDialog* _tmp10_ = NULL;
	GtkDialog* _tmp11_ = NULL;
	GtkDialog* _tmp12_ = NULL;
	GtkGrid* grid = NULL;
	GtkGrid* _tmp13_ = NULL;
	GtkGrid* _tmp14_ = NULL;
	GtkGrid* _tmp15_ = NULL;
	GtkGrid* _tmp16_ = NULL;
	GtkLabel* label = NULL;
	const gchar* _tmp17_ = NULL;
	GtkLabel* _tmp18_ = NULL;
	GtkLabel* _tmp19_ = NULL;
	GtkGrid* _tmp20_ = NULL;
	GtkLabel* _tmp21_ = NULL;
	GList* themes = NULL;
	GList* _tmp22_ = NULL;
	GtkComboBox* theme_combo = NULL;
	GtkComboBox* _tmp23_ = NULL;
	GtkListStore* theme_store = NULL;
	GtkListStore* _tmp24_ = NULL;
	GtkComboBox* _tmp25_ = NULL;
	GtkListStore* _tmp26_ = NULL;
	GtkCellRendererText* renderer = NULL;
	GtkCellRendererText* _tmp27_ = NULL;
	GtkComboBox* _tmp28_ = NULL;
	GtkCellRendererText* _tmp29_ = NULL;
	GtkComboBox* _tmp30_ = NULL;
	GtkCellRendererText* _tmp31_ = NULL;
	GList* _tmp32_ = NULL;
	GtkComboBox* _tmp53_ = NULL;
	GtkComboBox* _tmp54_ = NULL;
	GtkGrid* _tmp55_ = NULL;
	GtkComboBox* _tmp56_ = NULL;
	GtkLabel* _tmp57_ = NULL;
	GtkComboBox* _tmp58_ = NULL;
	const gchar* _tmp59_ = NULL;
	GtkLabel* _tmp60_ = NULL;
	GtkLabel* _tmp61_ = NULL;
	GtkGrid* _tmp62_ = NULL;
	GtkLabel* _tmp63_ = NULL;
	GtkComboBox* map_combo = NULL;
	GtkComboBox* _tmp64_ = NULL;
	GtkListStore* map_store = NULL;
	GtkListStore* _tmp65_ = NULL;
	GtkComboBox* _tmp66_ = NULL;
	GtkListStore* _tmp67_ = NULL;
	GtkCellRendererText* _tmp68_ = NULL;
	GtkComboBox* _tmp69_ = NULL;
	GtkCellRendererText* _tmp70_ = NULL;
	GtkComboBox* _tmp71_ = NULL;
	GtkCellRendererText* _tmp72_ = NULL;
	GList* _tmp73_ = NULL;
	GtkComboBox* _tmp93_ = NULL;
	GtkComboBox* _tmp94_ = NULL;
	GtkGrid* _tmp95_ = NULL;
	GtkComboBox* _tmp96_ = NULL;
	GtkLabel* _tmp97_ = NULL;
	GtkComboBox* _tmp98_ = NULL;
	const gchar* _tmp99_ = NULL;
	GtkLabel* _tmp100_ = NULL;
	GtkLabel* _tmp101_ = NULL;
	GtkGrid* _tmp102_ = NULL;
	GtkLabel* _tmp103_ = NULL;
	GtkColorButton* widget = NULL;
	GtkColorButton* _tmp104_ = NULL;
	GtkColorButton* _tmp105_ = NULL;
	GameView* _tmp106_ = NULL;
	GdkRGBA _tmp107_ = {0};
	GtkColorButton* _tmp108_ = NULL;
	GtkColorButton* _tmp109_ = NULL;
	GtkGrid* _tmp110_ = NULL;
	GtkColorButton* _tmp111_ = NULL;
	GtkLabel* _tmp112_ = NULL;
	GtkColorButton* _tmp113_ = NULL;
	GtkCheckButton* auto_play_button = NULL;
	const gchar* _tmp114_ = NULL;
	GtkCheckButton* _tmp115_ = NULL;
	GtkCheckButton* _tmp116_ = NULL;
	GtkCheckButton* _tmp117_ = NULL;
	GtkCheckButton* _tmp118_ = NULL;
	GSettings* _tmp119_ = NULL;
	gboolean _tmp120_ = FALSE;
	GtkGrid* _tmp121_ = NULL;
	GtkCheckButton* _tmp122_ = NULL;
	GtkBox* _tmp123_ = NULL;
	GtkGrid* _tmp124_ = NULL;
	GtkDialog* _tmp125_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->preferences_dialog;
	if (_tmp0_ != NULL) {
		GtkDialog* _tmp1_ = NULL;
		_tmp1_ = self->priv->preferences_dialog;
		gtk_window_present ((GtkWindow*) _tmp1_);
		return;
	}
	_tmp2_ = _ ("Mahjongg Preferences");
	_tmp3_ = self->priv->window;
	_tmp4_ = (GtkDialog*) gtk_dialog_new_with_buttons (_tmp2_, (GtkWindow*) _tmp3_, GTK_DIALOG_DESTROY_WITH_PARENT, GTK_STOCK_CLOSE, GTK_RESPONSE_CLOSE, NULL, NULL);
	g_object_ref_sink (_tmp4_);
	_g_object_unref0 (self->priv->preferences_dialog);
	self->priv->preferences_dialog = _tmp4_;
	_tmp5_ = self->priv->preferences_dialog;
	gtk_container_set_border_width ((GtkContainer*) _tmp5_, (guint) 5);
	_tmp6_ = self->priv->preferences_dialog;
	_tmp7_ = (GtkBox*) gtk_dialog_get_content_area (_tmp6_);
	_tmp8_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp7_, GTK_TYPE_BOX, GtkBox));
	dialog_content_area = _tmp8_;
	_tmp9_ = dialog_content_area;
	gtk_box_set_spacing (_tmp9_, 2);
	_tmp10_ = self->priv->preferences_dialog;
	gtk_window_set_resizable ((GtkWindow*) _tmp10_, FALSE);
	_tmp11_ = self->priv->preferences_dialog;
	gtk_dialog_set_default_response (_tmp11_, (gint) GTK_RESPONSE_CLOSE);
	_tmp12_ = self->priv->preferences_dialog;
	g_signal_connect_object (_tmp12_, "response", (GCallback) _mahjongg_preferences_dialog_response_cb_gtk_dialog_response, self, 0);
	_tmp13_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp13_);
	grid = _tmp13_;
	_tmp14_ = grid;
	gtk_container_set_border_width ((GtkContainer*) _tmp14_, (guint) 5);
	_tmp15_ = grid;
	gtk_grid_set_row_spacing (_tmp15_, (guint) 6);
	_tmp16_ = grid;
	gtk_grid_set_column_spacing (_tmp16_, (guint) 18);
	_tmp17_ = _ ("_Theme:");
	_tmp18_ = (GtkLabel*) gtk_label_new_with_mnemonic (_tmp17_);
	g_object_ref_sink (_tmp18_);
	label = _tmp18_;
	_tmp19_ = label;
	gtk_misc_set_alignment ((GtkMisc*) _tmp19_, (gfloat) 0, 0.5f);
	_tmp20_ = grid;
	_tmp21_ = label;
	gtk_grid_attach (_tmp20_, (GtkWidget*) _tmp21_, 0, 0, 1, 1);
	_tmp22_ = mahjongg_load_themes (self);
	themes = _tmp22_;
	_tmp23_ = (GtkComboBox*) gtk_combo_box_new ();
	g_object_ref_sink (_tmp23_);
	theme_combo = _tmp23_;
	_tmp24_ = gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_STRING);
	theme_store = _tmp24_;
	_tmp25_ = theme_combo;
	_tmp26_ = theme_store;
	gtk_combo_box_set_model (_tmp25_, (GtkTreeModel*) _tmp26_);
	_tmp27_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp27_);
	renderer = _tmp27_;
	_tmp28_ = theme_combo;
	_tmp29_ = renderer;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp28_, (GtkCellRenderer*) _tmp29_, TRUE);
	_tmp30_ = theme_combo;
	_tmp31_ = renderer;
	gtk_cell_layout_add_attribute ((GtkCellLayout*) _tmp30_, (GtkCellRenderer*) _tmp31_, "text", 0);
	_tmp32_ = themes;
	{
		GList* theme_collection = NULL;
		GList* theme_it = NULL;
		theme_collection = _tmp32_;
		for (theme_it = theme_collection; theme_it != NULL; theme_it = theme_it->next) {
			gchar* _tmp33_ = NULL;
			gchar* theme = NULL;
			_tmp33_ = g_strdup ((const gchar*) theme_it->data);
			theme = _tmp33_;
			{
				gchar** tokens = NULL;
				const gchar* _tmp34_ = NULL;
				gchar** _tmp35_ = NULL;
				gchar** _tmp36_ = NULL;
				gint tokens_length1 = 0;
				gint _tokens_size_ = 0;
				gchar* name = NULL;
				gchar** _tmp37_ = NULL;
				gint _tmp37__length1 = 0;
				const gchar* _tmp38_ = NULL;
				gchar* _tmp39_ = NULL;
				GtkTreeIter iter = {0};
				GtkListStore* _tmp40_ = NULL;
				GtkTreeIter _tmp41_ = {0};
				GtkListStore* _tmp42_ = NULL;
				GtkTreeIter _tmp43_ = {0};
				const gchar* _tmp44_ = NULL;
				const gchar* _tmp45_ = NULL;
				const gchar* _tmp46_ = NULL;
				GSettings* _tmp47_ = NULL;
				gchar* _tmp48_ = NULL;
				gchar* _tmp49_ = NULL;
				gboolean _tmp50_ = FALSE;
				_tmp34_ = theme;
				_tmp36_ = _tmp35_ = g_strsplit (_tmp34_, ".", -1);
				tokens = _tmp36_;
				tokens_length1 = _vala_array_length (_tmp35_);
				_tokens_size_ = tokens_length1;
				_tmp37_ = tokens;
				_tmp37__length1 = tokens_length1;
				_tmp38_ = _tmp37_[0];
				_tmp39_ = g_strdup (_tmp38_);
				name = _tmp39_;
				_tmp40_ = theme_store;
				gtk_list_store_append (_tmp40_, &_tmp41_);
				iter = _tmp41_;
				_tmp42_ = theme_store;
				_tmp43_ = iter;
				_tmp44_ = name;
				_tmp45_ = theme;
				gtk_list_store_set (_tmp42_, &_tmp43_, 0, _tmp44_, 1, _tmp45_, -1, -1);
				_tmp46_ = theme;
				_tmp47_ = self->priv->settings;
				_tmp48_ = g_settings_get_string (_tmp47_, "tileset");
				_tmp49_ = _tmp48_;
				_tmp50_ = g_strcmp0 (_tmp46_, _tmp49_) == 0;
				_g_free0 (_tmp49_);
				if (_tmp50_) {
					GtkComboBox* _tmp51_ = NULL;
					GtkTreeIter _tmp52_ = {0};
					_tmp51_ = theme_combo;
					_tmp52_ = iter;
					gtk_combo_box_set_active_iter (_tmp51_, &_tmp52_);
				}
				_g_free0 (name);
				tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (theme);
			}
		}
	}
	_tmp53_ = theme_combo;
	g_signal_connect_object (_tmp53_, "changed", (GCallback) _mahjongg_theme_changed_cb_gtk_combo_box_changed, self, 0);
	_tmp54_ = theme_combo;
	gtk_widget_set_hexpand ((GtkWidget*) _tmp54_, TRUE);
	_tmp55_ = grid;
	_tmp56_ = theme_combo;
	gtk_grid_attach (_tmp55_, (GtkWidget*) _tmp56_, 1, 0, 1, 1);
	_tmp57_ = label;
	_tmp58_ = theme_combo;
	gtk_label_set_mnemonic_widget (_tmp57_, (GtkWidget*) _tmp58_);
	_tmp59_ = _ ("_Layout:");
	_tmp60_ = (GtkLabel*) gtk_label_new_with_mnemonic (_tmp59_);
	g_object_ref_sink (_tmp60_);
	_g_object_unref0 (label);
	label = _tmp60_;
	_tmp61_ = label;
	gtk_misc_set_alignment ((GtkMisc*) _tmp61_, (gfloat) 0, 0.5f);
	_tmp62_ = grid;
	_tmp63_ = label;
	gtk_grid_attach (_tmp62_, (GtkWidget*) _tmp63_, 0, 1, 1, 1);
	_tmp64_ = (GtkComboBox*) gtk_combo_box_new ();
	g_object_ref_sink (_tmp64_);
	map_combo = _tmp64_;
	_tmp65_ = gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_STRING);
	map_store = _tmp65_;
	_tmp66_ = map_combo;
	_tmp67_ = map_store;
	gtk_combo_box_set_model (_tmp66_, (GtkTreeModel*) _tmp67_);
	_tmp68_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp68_);
	_g_object_unref0 (renderer);
	renderer = _tmp68_;
	_tmp69_ = map_combo;
	_tmp70_ = renderer;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp69_, (GtkCellRenderer*) _tmp70_, TRUE);
	_tmp71_ = map_combo;
	_tmp72_ = renderer;
	gtk_cell_layout_add_attribute ((GtkCellLayout*) _tmp71_, (GtkCellRenderer*) _tmp72_, "text", 0);
	_tmp73_ = self->priv->maps;
	{
		GList* map_collection = NULL;
		GList* map_it = NULL;
		map_collection = _tmp73_;
		for (map_it = map_collection; map_it != NULL; map_it = map_it->next) {
			Map* _tmp74_ = NULL;
			Map* map = NULL;
			_tmp74_ = _map_ref0 ((Map*) map_it->data);
			map = _tmp74_;
			{
				gchar* display_name = NULL;
				Map* _tmp75_ = NULL;
				const gchar* _tmp76_ = NULL;
				const gchar* _tmp77_ = NULL;
				gchar* _tmp78_ = NULL;
				GtkTreeIter iter = {0};
				GtkListStore* _tmp79_ = NULL;
				GtkTreeIter _tmp80_ = {0};
				GtkListStore* _tmp81_ = NULL;
				GtkTreeIter _tmp82_ = {0};
				const gchar* _tmp83_ = NULL;
				Map* _tmp84_ = NULL;
				GSettings* _tmp85_ = NULL;
				gchar* _tmp86_ = NULL;
				gchar* _tmp87_ = NULL;
				Map* _tmp88_ = NULL;
				const gchar* _tmp89_ = NULL;
				gboolean _tmp90_ = FALSE;
				_tmp75_ = map;
				_tmp76_ = _tmp75_->name;
				_tmp77_ = g_dpgettext2 (NULL, "mahjongg map name", _tmp76_);
				_tmp78_ = g_strdup (_tmp77_);
				display_name = _tmp78_;
				_tmp79_ = map_store;
				gtk_list_store_append (_tmp79_, &_tmp80_);
				iter = _tmp80_;
				_tmp81_ = map_store;
				_tmp82_ = iter;
				_tmp83_ = display_name;
				_tmp84_ = map;
				gtk_list_store_set (_tmp81_, &_tmp82_, 0, _tmp83_, 1, _tmp84_, -1, -1);
				_tmp85_ = self->priv->settings;
				_tmp86_ = g_settings_get_string (_tmp85_, "mapset");
				_tmp87_ = _tmp86_;
				_tmp88_ = map;
				_tmp89_ = _tmp88_->name;
				_tmp90_ = g_strcmp0 (_tmp87_, _tmp89_) == 0;
				_g_free0 (_tmp87_);
				if (_tmp90_) {
					GtkComboBox* _tmp91_ = NULL;
					GtkTreeIter _tmp92_ = {0};
					_tmp91_ = map_combo;
					_tmp92_ = iter;
					gtk_combo_box_set_active_iter (_tmp91_, &_tmp92_);
				}
				_g_free0 (display_name);
				_map_unref0 (map);
			}
		}
	}
	_tmp93_ = map_combo;
	g_signal_connect_object (_tmp93_, "changed", (GCallback) _mahjongg_map_changed_cb_gtk_combo_box_changed, self, 0);
	_tmp94_ = map_combo;
	gtk_widget_set_hexpand ((GtkWidget*) _tmp94_, TRUE);
	_tmp95_ = grid;
	_tmp96_ = map_combo;
	gtk_grid_attach (_tmp95_, (GtkWidget*) _tmp96_, 1, 1, 1, 1);
	_tmp97_ = label;
	_tmp98_ = map_combo;
	gtk_label_set_mnemonic_widget (_tmp97_, (GtkWidget*) _tmp98_);
	_tmp99_ = _ ("_Background color:");
	_tmp100_ = (GtkLabel*) gtk_label_new_with_mnemonic (_tmp99_);
	g_object_ref_sink (_tmp100_);
	_g_object_unref0 (label);
	label = _tmp100_;
	_tmp101_ = label;
	gtk_misc_set_alignment ((GtkMisc*) _tmp101_, (gfloat) 0, 0.5f);
	_tmp102_ = grid;
	_tmp103_ = label;
	gtk_grid_attach (_tmp102_, (GtkWidget*) _tmp103_, 0, 2, 1, 1);
	_tmp104_ = (GtkColorButton*) gtk_color_button_new ();
	g_object_ref_sink (_tmp104_);
	widget = _tmp104_;
	_tmp105_ = widget;
	_tmp106_ = self->priv->game_view;
	_tmp107_ = _tmp106_->background_color;
	gtk_color_chooser_set_rgba ((GtkColorChooser*) _tmp105_, &_tmp107_);
	_tmp108_ = widget;
	g_signal_connect_object (_tmp108_, "color-set", (GCallback) _mahjongg_background_changed_cb_gtk_color_button_color_set, self, 0);
	_tmp109_ = widget;
	gtk_widget_set_hexpand ((GtkWidget*) _tmp109_, TRUE);
	_tmp110_ = grid;
	_tmp111_ = widget;
	gtk_grid_attach (_tmp110_, (GtkWidget*) _tmp111_, 1, 2, 1, 1);
	_tmp112_ = label;
	_tmp113_ = widget;
	gtk_label_set_mnemonic_widget (_tmp112_, (GtkWidget*) _tmp113_);
	_tmp114_ = _ ("_Auto play");
	_tmp115_ = (GtkCheckButton*) gtk_check_button_new_with_mnemonic (_tmp114_);
	g_object_ref_sink (_tmp115_);
	auto_play_button = _tmp115_;
	_tmp116_ = auto_play_button;
	gtk_widget_show ((GtkWidget*) _tmp116_);
	_tmp117_ = auto_play_button;
	g_signal_connect_object ((GtkToggleButton*) _tmp117_, "toggled", (GCallback) _mahjongg_toggle_auto_play_cb_gtk_toggle_button_toggled, self, 0);
	_tmp118_ = auto_play_button;
	_tmp119_ = self->priv->settings;
	_tmp120_ = g_settings_get_boolean (_tmp119_, "autoplay");
	gtk_toggle_button_set_active ((GtkToggleButton*) _tmp118_, _tmp120_);
	_tmp121_ = grid;
	_tmp122_ = auto_play_button;
	gtk_grid_attach (_tmp121_, (GtkWidget*) _tmp122_, 0, 4, 1, 1);
	_tmp123_ = dialog_content_area;
	_tmp124_ = grid;
	gtk_box_pack_start (_tmp123_, (GtkWidget*) _tmp124_, TRUE, TRUE, (guint) 0);
	_tmp125_ = self->priv->preferences_dialog;
	gtk_widget_show_all ((GtkWidget*) _tmp125_);
	_g_object_unref0 (auto_play_button);
	_g_object_unref0 (widget);
	_g_object_unref0 (map_store);
	_g_object_unref0 (map_combo);
	_g_object_unref0 (renderer);
	_g_object_unref0 (theme_store);
	_g_object_unref0 (theme_combo);
	__g_list_free__g_free0_0 (themes);
	_g_object_unref0 (label);
	_g_object_unref0 (grid);
	_g_object_unref0 (dialog_content_area);
}


static void mahjongg_preferences_dialog_response_cb (Mahjongg* self, GtkDialog* dialog, gint response) {
	GtkDialog* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dialog != NULL);
	_tmp0_ = self->priv->preferences_dialog;
	gtk_widget_destroy ((GtkWidget*) _tmp0_);
	_g_object_unref0 (self->priv->preferences_dialog);
	self->priv->preferences_dialog = NULL;
}


static GList* mahjongg_load_themes (Mahjongg* self) {
	GList* result = NULL;
	GList* themes = NULL;
	GDir* dir = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	themes = NULL;
	{
		GDir* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GDir* _tmp3_ = NULL;
		GDir* _tmp4_ = NULL;
		_tmp1_ = g_build_filename (DATA_DIRECTORY, "themes", NULL);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_dir_open (_tmp2_, (guint) 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		_tmp0_ = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch4_g_file_error;
			}
			_g_dir_close0 (dir);
			__g_list_free__g_free0_0 (themes);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_g_dir_close0 (dir);
		dir = _tmp0_;
	}
	goto __finally4;
	__catch4_g_file_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		result = themes;
		_g_error_free0 (e);
		_g_dir_close0 (dir);
		return result;
	}
	__finally4:
	if (_inner_error_ != NULL) {
		_g_dir_close0 (dir);
		__g_list_free__g_free0_0 (themes);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	while (TRUE) {
		gchar* s = NULL;
		GDir* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		gboolean _tmp10_ = FALSE;
		gboolean _tmp11_ = FALSE;
		gboolean _tmp12_ = FALSE;
		gboolean _tmp13_ = FALSE;
		const gchar* _tmp14_ = NULL;
		gboolean _tmp15_ = FALSE;
		gboolean _tmp18_ = FALSE;
		gboolean _tmp21_ = FALSE;
		gboolean _tmp24_ = FALSE;
		gboolean _tmp27_ = FALSE;
		gboolean _tmp30_ = FALSE;
		_tmp5_ = dir;
		_tmp6_ = g_dir_read_name (_tmp5_);
		_tmp7_ = g_strdup (_tmp6_);
		s = _tmp7_;
		_tmp8_ = s;
		if (_tmp8_ == NULL) {
			_g_free0 (s);
			break;
		}
		_tmp14_ = s;
		_tmp15_ = g_str_has_suffix (_tmp14_, ".xpm");
		if (_tmp15_) {
			_tmp13_ = TRUE;
		} else {
			const gchar* _tmp16_ = NULL;
			gboolean _tmp17_ = FALSE;
			_tmp16_ = s;
			_tmp17_ = g_str_has_suffix (_tmp16_, ".svg");
			_tmp13_ = _tmp17_;
		}
		_tmp18_ = _tmp13_;
		if (_tmp18_) {
			_tmp12_ = TRUE;
		} else {
			const gchar* _tmp19_ = NULL;
			gboolean _tmp20_ = FALSE;
			_tmp19_ = s;
			_tmp20_ = g_str_has_suffix (_tmp19_, ".gif");
			_tmp12_ = _tmp20_;
		}
		_tmp21_ = _tmp12_;
		if (_tmp21_) {
			_tmp11_ = TRUE;
		} else {
			const gchar* _tmp22_ = NULL;
			gboolean _tmp23_ = FALSE;
			_tmp22_ = s;
			_tmp23_ = g_str_has_suffix (_tmp22_, ".png");
			_tmp11_ = _tmp23_;
		}
		_tmp24_ = _tmp11_;
		if (_tmp24_) {
			_tmp10_ = TRUE;
		} else {
			const gchar* _tmp25_ = NULL;
			gboolean _tmp26_ = FALSE;
			_tmp25_ = s;
			_tmp26_ = g_str_has_suffix (_tmp25_, ".jpg");
			_tmp10_ = _tmp26_;
		}
		_tmp27_ = _tmp10_;
		if (_tmp27_) {
			_tmp9_ = TRUE;
		} else {
			const gchar* _tmp28_ = NULL;
			gboolean _tmp29_ = FALSE;
			_tmp28_ = s;
			_tmp29_ = g_str_has_suffix (_tmp28_, ".xbm");
			_tmp9_ = _tmp29_;
		}
		_tmp30_ = _tmp9_;
		if (_tmp30_) {
			const gchar* _tmp31_ = NULL;
			gchar* _tmp32_ = NULL;
			_tmp31_ = s;
			_tmp32_ = g_strdup (_tmp31_);
			themes = g_list_append (themes, _tmp32_);
		}
		_g_free0 (s);
	}
	result = themes;
	_g_dir_close0 (dir);
	return result;
}


static void _match_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (match_unref (var), NULL));
}


static void _g_list_free__match_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _match_unref0_, NULL);
	g_list_free (self);
}


static gpointer _match_ref0 (gpointer self) {
	return self ? match_ref (self) : NULL;
}


static void mahjongg_hint_cb (Mahjongg* self) {
	GList* matches = NULL;
	GameView* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	GameView* _tmp3_ = NULL;
	Game* _tmp4_ = NULL;
	Game* _tmp5_ = NULL;
	Tile* _tmp6_ = NULL;
	Tile* _tmp7_ = NULL;
	GList* _tmp8_ = NULL;
	guint n_matches = 0U;
	GList* _tmp9_ = NULL;
	guint _tmp10_ = 0U;
	guint _tmp11_ = 0U;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->game_view;
	_tmp1_ = game_view_get_game (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->game_view;
	_tmp4_ = game_view_get_game (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = game_get_selected_tile (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = game_find_matches (_tmp2_, _tmp7_);
	matches = _tmp8_;
	_tmp9_ = matches;
	_tmp10_ = g_list_length (_tmp9_);
	n_matches = _tmp10_;
	_tmp11_ = n_matches;
	if (_tmp11_ == ((guint) 0)) {
		GameView* _tmp12_ = NULL;
		Game* _tmp13_ = NULL;
		Game* _tmp14_ = NULL;
		Tile* _tmp15_ = NULL;
		Tile* _tmp16_ = NULL;
		GameView* _tmp17_ = NULL;
		Game* _tmp18_ = NULL;
		Game* _tmp19_ = NULL;
		GameView* _tmp20_ = NULL;
		Game* _tmp21_ = NULL;
		Game* _tmp22_ = NULL;
		Tile* _tmp23_ = NULL;
		Tile* _tmp24_ = NULL;
		_tmp12_ = self->priv->game_view;
		_tmp13_ = game_view_get_game (_tmp12_);
		_tmp14_ = _tmp13_;
		_tmp15_ = game_get_selected_tile (_tmp14_);
		_tmp16_ = _tmp15_;
		if (_tmp16_ == NULL) {
			__g_list_free__match_unref0_0 (matches);
			return;
		}
		_tmp17_ = self->priv->game_view;
		_tmp18_ = game_view_get_game (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = self->priv->game_view;
		_tmp21_ = game_view_get_game (_tmp20_);
		_tmp22_ = _tmp21_;
		_tmp23_ = game_get_selected_tile (_tmp22_);
		_tmp24_ = _tmp23_;
		game_set_hint (_tmp19_, _tmp24_, NULL);
	} else {
		gint32 n = 0;
		guint _tmp25_ = 0U;
		gint32 _tmp26_ = 0;
		Match* match = NULL;
		GList* _tmp27_ = NULL;
		gint32 _tmp28_ = 0;
		gconstpointer _tmp29_ = NULL;
		Match* _tmp30_ = NULL;
		GameView* _tmp31_ = NULL;
		Game* _tmp32_ = NULL;
		Game* _tmp33_ = NULL;
		Match* _tmp34_ = NULL;
		Tile* _tmp35_ = NULL;
		Match* _tmp36_ = NULL;
		Tile* _tmp37_ = NULL;
		_tmp25_ = n_matches;
		_tmp26_ = g_random_int_range ((gint32) 0, (gint32) ((gint) _tmp25_));
		n = _tmp26_;
		_tmp27_ = matches;
		_tmp28_ = n;
		_tmp29_ = g_list_nth_data (_tmp27_, (guint) _tmp28_);
		_tmp30_ = _match_ref0 ((Match*) _tmp29_);
		match = _tmp30_;
		_tmp31_ = self->priv->game_view;
		_tmp32_ = game_view_get_game (_tmp31_);
		_tmp33_ = _tmp32_;
		_tmp34_ = match;
		_tmp35_ = _tmp34_->tile0;
		_tmp36_ = match;
		_tmp37_ = _tmp36_->tile1;
		game_set_hint (_tmp33_, _tmp35_, _tmp37_);
		_match_unref0 (match);
	}
	mahjongg_update_ui (self);
	__g_list_free__match_unref0_0 (matches);
}


static void mahjongg_about_cb (Mahjongg* self) {
	gchar** authors = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar** _tmp14_ = NULL;
	gint authors_length1 = 0;
	gint _authors_size_ = 0;
	gchar** artists = NULL;
	const gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	gchar* _tmp19_ = NULL;
	gchar* _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	gchar** _tmp22_ = NULL;
	gint artists_length1 = 0;
	gint _artists_size_ = 0;
	gchar** documenters = NULL;
	gchar* _tmp23_ = NULL;
	gchar* _tmp24_ = NULL;
	gchar** _tmp25_ = NULL;
	gint documenters_length1 = 0;
	gint _documenters_size_ = 0;
	gchar* license = NULL;
	gchar* _tmp26_ = NULL;
	GtkApplicationWindow* _tmp27_ = NULL;
	const gchar* _tmp28_ = NULL;
	const gchar* _tmp29_ = NULL;
	const gchar* _tmp30_ = NULL;
	const gchar* _tmp31_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = _ ("Main game:");
	_tmp1_ = g_strdup (_tmp0_);
	_tmp2_ = g_strdup ("Francisco Bustamante");
	_tmp3_ = g_strdup ("Max Watson");
	_tmp4_ = g_strdup ("Heinz Hempe");
	_tmp5_ = g_strdup ("Michael Meeks");
	_tmp6_ = g_strdup ("Philippe Chavin");
	_tmp7_ = g_strdup ("Callum McKenzie");
	_tmp8_ = g_strdup ("Robert Ancell");
	_tmp9_ = g_strdup ("");
	_tmp10_ = _ ("Maps:");
	_tmp11_ = g_strdup (_tmp10_);
	_tmp12_ = g_strdup ("Rexford Newbould");
	_tmp13_ = g_strdup ("Krzysztof Foltman");
	_tmp14_ = g_new0 (gchar*, 13 + 1);
	_tmp14_[0] = _tmp1_;
	_tmp14_[1] = _tmp2_;
	_tmp14_[2] = _tmp3_;
	_tmp14_[3] = _tmp4_;
	_tmp14_[4] = _tmp5_;
	_tmp14_[5] = _tmp6_;
	_tmp14_[6] = _tmp7_;
	_tmp14_[7] = _tmp8_;
	_tmp14_[8] = _tmp9_;
	_tmp14_[9] = _tmp11_;
	_tmp14_[10] = _tmp12_;
	_tmp14_[11] = _tmp13_;
	_tmp14_[12] = NULL;
	authors = _tmp14_;
	authors_length1 = 13;
	_authors_size_ = authors_length1;
	_tmp15_ = _ ("Tiles:");
	_tmp16_ = g_strdup (_tmp15_);
	_tmp17_ = g_strdup ("Jonathan Buzzard");
	_tmp18_ = g_strdup ("Jim Evans");
	_tmp19_ = g_strdup ("Richard Hoelscher");
	_tmp20_ = g_strdup ("Gonzalo Odiard");
	_tmp21_ = g_strdup ("Max Watson");
	_tmp22_ = g_new0 (gchar*, 7 + 1);
	_tmp22_[0] = _tmp16_;
	_tmp22_[1] = _tmp17_;
	_tmp22_[2] = _tmp18_;
	_tmp22_[3] = _tmp19_;
	_tmp22_[4] = _tmp20_;
	_tmp22_[5] = _tmp21_;
	_tmp22_[6] = NULL;
	artists = _tmp22_;
	artists_length1 = 7;
	_artists_size_ = artists_length1;
	_tmp23_ = g_strdup ("Tiffany Antopolski");
	_tmp24_ = g_strdup ("Chris Beiser");
	_tmp25_ = g_new0 (gchar*, 3 + 1);
	_tmp25_[0] = _tmp23_;
	_tmp25_[1] = _tmp24_;
	_tmp25_[2] = NULL;
	documenters = _tmp25_;
	documenters_length1 = 3;
	_documenters_size_ = documenters_length1;
	_tmp26_ = g_strdup ("Mahjongg is free software; you can redistribute it and/or modify it un" \
"der the terms of the GNU General Public License as published by the Fr" \
"ee Software Foundation; either version 2 of the License, or (at your o" \
"ption) any later version.\n" \
"\n" \
"Mahjongg is distributed in the hope that it will be useful, but WITHOU" \
"T ANY WARRANTY; without even the implied warranty of MERCHANTABILITY o" \
"r FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License" \
" for more details.\n" \
"\n" \
"You should have received a copy of the GNU General Public License alon" \
"g with Mahjongg; if not, write to the Free Software Foundation, Inc., " \
"51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA");
	license = _tmp26_;
	_tmp27_ = self->priv->window;
	_tmp28_ = _ ("Mahjongg");
	_tmp29_ = _ ("A matching game played with Mahjongg tiles.\n" \
"\n" \
"Mahjongg is a part of GNOME Games.");
	_tmp30_ = _ ("translator-credits");
	_tmp31_ = _ ("GNOME Games web site");
	gtk_show_about_dialog ((GtkWindow*) _tmp27_, "program-name", _tmp28_, "version", VERSION, "comments", _tmp29_, "copyright", "Copyright \xc2\xa9 1998-2008 Free Software Foundation, Inc.", "license", license, "wrap-license", TRUE, "authors", authors, "artists", artists, "documenters", documenters, "translator-credits", _tmp30_, "logo-icon-name", "gnome-mahjongg", "website", "http://www.gnome.org/projects/gnome-games", "website-label", _tmp31_, NULL, NULL);
	_g_free0 (license);
	documenters = (_vala_array_free (documenters, documenters_length1, (GDestroyNotify) g_free), NULL);
	artists = (_vala_array_free (artists, artists_length1, (GDestroyNotify) g_free), NULL);
	authors = (_vala_array_free (authors, authors_length1, (GDestroyNotify) g_free), NULL);
}


static void mahjongg_pause_cb (Mahjongg* self) {
	GameView* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	GameView* _tmp3_ = NULL;
	Game* _tmp4_ = NULL;
	Game* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	GameView* _tmp8_ = NULL;
	Game* _tmp9_ = NULL;
	Game* _tmp10_ = NULL;
	GameView* _tmp11_ = NULL;
	Game* _tmp12_ = NULL;
	Game* _tmp13_ = NULL;
	GameView* _tmp14_ = NULL;
	Game* _tmp15_ = NULL;
	Game* _tmp16_ = NULL;
	gboolean _tmp17_ = FALSE;
	gboolean _tmp18_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->game_view;
	_tmp1_ = game_view_get_game (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->priv->game_view;
	_tmp4_ = game_view_get_game (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = game_get_paused (_tmp5_);
	_tmp7_ = _tmp6_;
	game_set_paused (_tmp2_, !_tmp7_);
	_tmp8_ = self->priv->game_view;
	_tmp9_ = game_view_get_game (_tmp8_);
	_tmp10_ = _tmp9_;
	game_set_hint (_tmp10_, NULL, NULL);
	_tmp11_ = self->priv->game_view;
	_tmp12_ = game_view_get_game (_tmp11_);
	_tmp13_ = _tmp12_;
	game_set_selected_tile (_tmp13_, NULL);
	_tmp14_ = self->priv->game_view;
	_tmp15_ = game_view_get_game (_tmp14_);
	_tmp16_ = _tmp15_;
	_tmp17_ = game_get_paused (_tmp16_);
	_tmp18_ = _tmp17_;
	if (_tmp18_) {
		GtkToolButton* _tmp19_ = NULL;
		GtkToolButton* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		_tmp19_ = self->priv->pause_button;
		gtk_tool_button_set_icon_name (_tmp19_, "media-playback-start");
		_tmp20_ = self->priv->pause_button;
		_tmp21_ = _ ("Res_ume");
		gtk_tool_button_set_label (_tmp20_, _tmp21_);
	} else {
		GtkToolButton* _tmp22_ = NULL;
		GtkToolButton* _tmp23_ = NULL;
		const gchar* _tmp24_ = NULL;
		_tmp22_ = self->priv->pause_button;
		gtk_tool_button_set_icon_name (_tmp22_, "media-playback-pause");
		_tmp23_ = self->priv->pause_button;
		_tmp24_ = _ ("_Pause");
		gtk_tool_button_set_label (_tmp23_, _tmp24_);
	}
	mahjongg_update_ui (self);
}


static void mahjongg_scores_cb (Mahjongg* self) {
	g_return_if_fail (self != NULL);
	mahjongg_show_scores (self, NULL, FALSE);
}


static void mahjongg_new_game_cb (Mahjongg* self) {
	g_return_if_fail (self != NULL);
	mahjongg_new_game (self);
}


static void mahjongg_restart_game_cb (Mahjongg* self) {
	GameView* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	GameView* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->game_view;
	_tmp1_ = game_view_get_game (_tmp0_);
	_tmp2_ = _tmp1_;
	game_reset (_tmp2_);
	_tmp3_ = self->priv->game_view;
	gtk_widget_queue_draw ((GtkWidget*) _tmp3_);
}


static void mahjongg_quit_cb (Mahjongg* self) {
	GtkApplicationWindow* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->window;
	gtk_widget_destroy ((GtkWidget*) _tmp0_);
}


static void mahjongg_redo_cb (Mahjongg* self) {
	GameView* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	GameView* _tmp5_ = NULL;
	Game* _tmp6_ = NULL;
	Game* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->game_view;
	_tmp1_ = game_view_get_game (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = game_get_paused (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_) {
		return;
	}
	_tmp5_ = self->priv->game_view;
	_tmp6_ = game_view_get_game (_tmp5_);
	_tmp7_ = _tmp6_;
	game_redo (_tmp7_);
	mahjongg_update_ui (self);
}


static void mahjongg_undo_cb (Mahjongg* self) {
	GameView* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->game_view;
	_tmp1_ = game_view_get_game (_tmp0_);
	_tmp2_ = _tmp1_;
	game_undo (_tmp2_);
	mahjongg_update_ui (self);
}


static void mahjongg_restart_game (Mahjongg* self) {
	GameView* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->game_view;
	_tmp1_ = game_view_get_game (_tmp0_);
	_tmp2_ = _tmp1_;
	game_reset (_tmp2_);
	mahjongg_update_ui (self);
}


static void _mahjongg_moved_cb_game_moved (Game* _sender, gpointer self) {
	mahjongg_moved_cb (self);
}


static void _mahjongg_tick_cb_game_tick (Game* _sender, gpointer self) {
	mahjongg_tick_cb (self);
}


static void mahjongg_new_game (Mahjongg* self) {
	Map* map = NULL;
	GList* _tmp0_ = NULL;
	Map* _tmp10_ = NULL;
	GameView* _tmp14_ = NULL;
	Map* _tmp15_ = NULL;
	Game* _tmp16_ = NULL;
	Game* _tmp17_ = NULL;
	GameView* _tmp18_ = NULL;
	Game* _tmp19_ = NULL;
	Game* _tmp20_ = NULL;
	GameView* _tmp21_ = NULL;
	Game* _tmp22_ = NULL;
	Game* _tmp23_ = NULL;
	gchar* display_name = NULL;
	GameView* _tmp24_ = NULL;
	Game* _tmp25_ = NULL;
	Game* _tmp26_ = NULL;
	Map* _tmp27_ = NULL;
	const gchar* _tmp28_ = NULL;
	const gchar* _tmp29_ = NULL;
	gchar* _tmp30_ = NULL;
	GtkApplicationWindow* _tmp31_ = NULL;
	const gchar* _tmp32_ = NULL;
	gchar* _tmp33_ = NULL;
	gchar* _tmp34_ = NULL;
	GtkToolButton* _tmp35_ = NULL;
	GtkToolButton* _tmp36_ = NULL;
	const gchar* _tmp37_ = NULL;
	g_return_if_fail (self != NULL);
	map = NULL;
	_tmp0_ = self->priv->maps;
	{
		GList* m_collection = NULL;
		GList* m_it = NULL;
		m_collection = _tmp0_;
		for (m_it = m_collection; m_it != NULL; m_it = m_it->next) {
			Map* _tmp1_ = NULL;
			Map* m = NULL;
			_tmp1_ = _map_ref0 ((Map*) m_it->data);
			m = _tmp1_;
			{
				Map* _tmp2_ = NULL;
				const gchar* _tmp3_ = NULL;
				GSettings* _tmp4_ = NULL;
				gchar* _tmp5_ = NULL;
				gchar* _tmp6_ = NULL;
				gboolean _tmp7_ = FALSE;
				_tmp2_ = m;
				_tmp3_ = _tmp2_->name;
				_tmp4_ = self->priv->settings;
				_tmp5_ = g_settings_get_string (_tmp4_, "mapset");
				_tmp6_ = _tmp5_;
				_tmp7_ = g_strcmp0 (_tmp3_, _tmp6_) == 0;
				_g_free0 (_tmp6_);
				if (_tmp7_) {
					Map* _tmp8_ = NULL;
					Map* _tmp9_ = NULL;
					_tmp8_ = m;
					_tmp9_ = _map_ref0 (_tmp8_);
					_map_unref0 (map);
					map = _tmp9_;
					_map_unref0 (m);
					break;
				}
				_map_unref0 (m);
			}
		}
	}
	_tmp10_ = map;
	if (_tmp10_ == NULL) {
		GList* _tmp11_ = NULL;
		gconstpointer _tmp12_ = NULL;
		Map* _tmp13_ = NULL;
		_tmp11_ = self->priv->maps;
		_tmp12_ = g_list_nth_data (_tmp11_, (guint) 0);
		_tmp13_ = _map_ref0 ((Map*) _tmp12_);
		_map_unref0 (map);
		map = _tmp13_;
	}
	_tmp14_ = self->priv->game_view;
	_tmp15_ = map;
	_tmp16_ = game_new (_tmp15_);
	_tmp17_ = _tmp16_;
	game_view_set_game (_tmp14_, _tmp17_);
	_game_unref0 (_tmp17_);
	_tmp18_ = self->priv->game_view;
	_tmp19_ = game_view_get_game (_tmp18_);
	_tmp20_ = _tmp19_;
	g_signal_connect_object (_tmp20_, "moved", (GCallback) _mahjongg_moved_cb_game_moved, self, 0);
	_tmp21_ = self->priv->game_view;
	_tmp22_ = game_view_get_game (_tmp21_);
	_tmp23_ = _tmp22_;
	g_signal_connect_object (_tmp23_, "tick", (GCallback) _mahjongg_tick_cb_game_tick, self, 0);
	_tmp24_ = self->priv->game_view;
	_tmp25_ = game_view_get_game (_tmp24_);
	_tmp26_ = _tmp25_;
	_tmp27_ = _tmp26_->map;
	_tmp28_ = _tmp27_->name;
	_tmp29_ = g_dpgettext2 (NULL, "mahjongg map name", _tmp28_);
	_tmp30_ = g_strdup (_tmp29_);
	display_name = _tmp30_;
	_tmp31_ = self->priv->window;
	_tmp32_ = _ ("Mahjongg - %s");
	_tmp33_ = g_strdup_printf (_tmp32_, display_name);
	_tmp34_ = _tmp33_;
	gtk_window_set_title ((GtkWindow*) _tmp31_, _tmp34_);
	_g_free0 (_tmp34_);
	mahjongg_update_ui (self);
	_tmp35_ = self->priv->pause_button;
	gtk_tool_button_set_icon_name (_tmp35_, "media-playback-pause");
	_tmp36_ = self->priv->pause_button;
	_tmp37_ = _ ("_Pause");
	gtk_tool_button_set_label (_tmp36_, _tmp37_);
	_g_free0 (display_name);
	_map_unref0 (map);
}


static void mahjongg_tick_cb (Mahjongg* self) {
	gint elapsed = 0;
	GameView* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	gint hours = 0;
	gint _tmp8_ = 0;
	gint minutes = 0;
	gint _tmp9_ = 0;
	gint seconds = 0;
	gint _tmp10_ = 0;
	GtkLabel* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	g_return_if_fail (self != NULL);
	elapsed = 0;
	_tmp0_ = self->priv->game_view;
	_tmp1_ = game_view_get_game (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_ != NULL) {
		GameView* _tmp3_ = NULL;
		Game* _tmp4_ = NULL;
		Game* _tmp5_ = NULL;
		gdouble _tmp6_ = 0.0;
		gdouble _tmp7_ = 0.0;
		_tmp3_ = self->priv->game_view;
		_tmp4_ = game_view_get_game (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = game_get_elapsed (_tmp5_);
		_tmp7_ = _tmp6_;
		elapsed = (gint) (_tmp7_ + 0.5);
	}
	_tmp8_ = elapsed;
	hours = _tmp8_ / 3600;
	_tmp9_ = elapsed;
	minutes = (_tmp9_ - (hours * 3600)) / 60;
	_tmp10_ = elapsed;
	seconds = (_tmp10_ - (hours * 3600)) - (minutes * 60);
	_tmp11_ = self->priv->clock_label;
	_tmp12_ = _ ("Time");
	_tmp13_ = g_strdup_printf ("%s: %02d:%02d:%02d", _tmp12_, hours, minutes, seconds);
	_tmp14_ = _tmp13_;
	gtk_label_set_text (_tmp11_, _tmp14_);
	_g_free0 (_tmp14_);
}


static void mahjongg_help_cb (Mahjongg* self) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		GtkApplicationWindow* _tmp0_ = NULL;
		GdkScreen* _tmp1_ = NULL;
		guint32 _tmp2_ = 0U;
		_tmp0_ = self->priv->window;
		_tmp1_ = gtk_window_get_screen ((GtkWindow*) _tmp0_);
		_tmp2_ = gtk_get_current_event_time ();
		gtk_show_uri (_tmp1_, "help:gnome-mahjongg", _tmp2_, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch5_g_error;
		}
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		GError* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = e;
		_tmp4_ = _tmp3_->message;
		g_warning ("gnome-mahjongg.vala:687: Failed to show help: %s", _tmp4_);
		_g_error_free0 (e);
	}
	__finally5:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void mahjongg_load_maps (Mahjongg* self) {
	Map* _tmp0_ = NULL;
	GDir* dir = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	__g_list_free__map_unref0_0 (self->priv->maps);
	self->priv->maps = NULL;
	_tmp0_ = map_new_builtin ();
	self->priv->maps = g_list_append (self->priv->maps, _tmp0_);
	{
		GDir* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		GDir* _tmp4_ = NULL;
		GDir* _tmp5_ = NULL;
		_tmp2_ = g_build_filename (DATA_DIRECTORY, "maps", NULL);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_dir_open (_tmp3_, (guint) 0, &_inner_error_);
		_tmp5_ = _tmp4_;
		_g_free0 (_tmp3_);
		_tmp1_ = _tmp5_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch6_g_file_error;
			}
			_g_dir_close0 (dir);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_g_dir_close0 (dir);
		dir = _tmp1_;
	}
	goto __finally6;
	__catch6_g_file_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
		_g_dir_close0 (dir);
		return;
	}
	__finally6:
	if (_inner_error_ != NULL) {
		_g_dir_close0 (dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	while (TRUE) {
		gchar* filename = NULL;
		GDir* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		MapLoader* loader = NULL;
		MapLoader* _tmp12_ = NULL;
		gchar* path = NULL;
		const gchar* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		MapLoader* _tmp20_ = NULL;
		GList* _tmp21_ = NULL;
		_tmp6_ = dir;
		_tmp7_ = g_dir_read_name (_tmp6_);
		_tmp8_ = g_strdup (_tmp7_);
		filename = _tmp8_;
		_tmp9_ = filename;
		if (_tmp9_ == NULL) {
			_g_free0 (filename);
			break;
		}
		_tmp10_ = filename;
		_tmp11_ = g_str_has_suffix (_tmp10_, ".map");
		if (!_tmp11_) {
			_g_free0 (filename);
			continue;
		}
		_tmp12_ = map_loader_new ();
		loader = _tmp12_;
		_tmp13_ = filename;
		_tmp14_ = g_build_filename (DATA_DIRECTORY, "maps", _tmp13_, NULL);
		path = _tmp14_;
		{
			MapLoader* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			_tmp15_ = loader;
			_tmp16_ = path;
			map_loader_load (_tmp15_, _tmp16_, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch7_g_error;
			}
		}
		goto __finally7;
		__catch7_g_error:
		{
			GError* e = NULL;
			const gchar* _tmp17_ = NULL;
			GError* _tmp18_ = NULL;
			const gchar* _tmp19_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp17_ = path;
			_tmp18_ = e;
			_tmp19_ = _tmp18_->message;
			g_warning ("gnome-mahjongg.vala:739: Could not load map %s: %s\n", _tmp17_, _tmp19_);
			_g_error_free0 (e);
			_g_free0 (path);
			_map_loader_unref0 (loader);
			_g_free0 (filename);
			continue;
		}
		__finally7:
		if (_inner_error_ != NULL) {
			_g_free0 (path);
			_map_loader_unref0 (loader);
			_g_free0 (filename);
			_g_dir_close0 (dir);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp20_ = loader;
		_tmp21_ = _tmp20_->maps;
		{
			GList* map_collection = NULL;
			GList* map_it = NULL;
			map_collection = _tmp21_;
			for (map_it = map_collection; map_it != NULL; map_it = map_it->next) {
				Map* _tmp22_ = NULL;
				Map* map = NULL;
				_tmp22_ = _map_ref0 ((Map*) map_it->data);
				map = _tmp22_;
				{
					Map* _tmp23_ = NULL;
					Map* _tmp24_ = NULL;
					_tmp23_ = map;
					_tmp24_ = _map_ref0 (_tmp23_);
					self->priv->maps = g_list_append (self->priv->maps, _tmp24_);
					_map_unref0 (map);
				}
			}
		}
		_g_free0 (path);
		_map_loader_unref0 (loader);
		_g_free0 (filename);
	}
	_g_dir_close0 (dir);
}


gint mahjongg_main (gchar** args, int args_length1) {
	gint result = 0;
	GOptionContext* context = NULL;
	GOptionContext* _tmp0_ = NULL;
	GOptionContext* _tmp1_ = NULL;
	GOptionContext* _tmp2_ = NULL;
	GOptionGroup* _tmp3_ = NULL;
	const gchar* _tmp8_ = NULL;
	Mahjongg* app = NULL;
	Mahjongg* _tmp9_ = NULL;
	gint _result_ = 0;
	Mahjongg* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	GError * _inner_error_ = NULL;
	setlocale (LC_ALL, "");
	bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
	bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
	textdomain (GETTEXT_PACKAGE);
	g_set_prgname ("mahjongg");
	gtk_init (&args_length1, &args);
	_tmp0_ = g_option_context_new (NULL);
	context = _tmp0_;
	_tmp1_ = context;
	g_option_context_set_translation_domain (_tmp1_, GETTEXT_PACKAGE);
	_tmp2_ = context;
	_tmp3_ = gtk_get_option_group (TRUE);
	g_option_context_add_group (_tmp2_, _tmp3_);
	{
		GOptionContext* _tmp4_ = NULL;
		_tmp4_ = context;
		g_option_context_parse (_tmp4_, &args_length1, &args, &_inner_error_);
		if (_inner_error_ != NULL) {
			goto __catch8_g_error;
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		FILE* _tmp5_ = NULL;
		GError* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp5_ = stdout;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		fprintf (_tmp5_, "%s\n", _tmp7_);
		result = EXIT_FAILURE;
		_g_error_free0 (e);
		_g_option_context_free0 (context);
		return result;
	}
	__finally8:
	if (_inner_error_ != NULL) {
		_g_option_context_free0 (context);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return 0;
	}
	_tmp8_ = _ ("Mahjongg");
	g_set_application_name (_tmp8_);
	gtk_window_set_default_icon_name ("gnome-mahjongg");
	_tmp9_ = mahjongg_new ();
	app = _tmp9_;
	_tmp10_ = app;
	_tmp11_ = g_application_run ((GApplication*) _tmp10_, 0, NULL);
	_result_ = _tmp11_;
	g_settings_sync ();
	result = _result_;
	_g_object_unref0 (app);
	_g_option_context_free0 (context);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return mahjongg_main (argv, argc);
}


static void mahjongg_class_init (MahjonggClass * klass) {
	mahjongg_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MahjonggPrivate));
	G_APPLICATION_CLASS (klass)->startup = mahjongg_real_startup;
	G_APPLICATION_CLASS (klass)->shutdown = mahjongg_real_shutdown;
	G_APPLICATION_CLASS (klass)->activate = mahjongg_real_activate;
	G_OBJECT_CLASS (klass)->finalize = mahjongg_finalize;
}


static void mahjongg_instance_init (Mahjongg * self) {
	self->priv = MAHJONGG_GET_PRIVATE (self);
	self->priv->maps = NULL;
	self->priv->preferences_dialog = NULL;
}


static void mahjongg_finalize (GObject* obj) {
	Mahjongg * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_MAHJONGG, Mahjongg);
	_g_object_unref0 (self->priv->settings);
	_history_unref0 (self->priv->history);
	__g_list_free__map_unref0_0 (self->priv->maps);
	_g_object_unref0 (self->priv->window);
	_g_object_unref0 (self->priv->game_view);
	_g_object_unref0 (self->priv->pause_button);
	_g_object_unref0 (self->priv->status_item);
	_g_object_unref0 (self->priv->moves_label);
	_g_object_unref0 (self->priv->clock_label);
	_g_object_unref0 (self->priv->preferences_dialog);
	G_OBJECT_CLASS (mahjongg_parent_class)->finalize (obj);
}


GType mahjongg_get_type (void) {
	static volatile gsize mahjongg_type_id__volatile = 0;
	if (g_once_init_enter (&mahjongg_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MahjonggClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) mahjongg_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Mahjongg), 0, (GInstanceInitFunc) mahjongg_instance_init, NULL };
		GType mahjongg_type_id;
		mahjongg_type_id = g_type_register_static (GTK_TYPE_APPLICATION, "Mahjongg", &g_define_type_info, 0);
		g_once_init_leave (&mahjongg_type_id__volatile, mahjongg_type_id);
	}
	return mahjongg_type_id__volatile;
}


static gpointer _history_ref0 (gpointer self) {
	return self ? history_ref (self) : NULL;
}


static void _score_dialog_entry_added_cb_history_entry_added (History* _sender, HistoryEntry* entry, gpointer self) {
	score_dialog_entry_added_cb (self, entry);
}


static gpointer _history_entry_ref0 (gpointer self) {
	return self ? history_entry_ref (self) : NULL;
}


static void _score_dialog_size_changed_cb_gtk_combo_box_changed (GtkComboBox* _sender, gpointer self) {
	score_dialog_size_changed_cb (self, _sender);
}


ScoreDialog* score_dialog_construct (GType object_type, History* history, HistoryEntry* selected_entry, gboolean show_quit) {
	ScoreDialog * self = NULL;
	History* _tmp0_ = NULL;
	History* _tmp1_ = NULL;
	History* _tmp2_ = NULL;
	HistoryEntry* _tmp3_ = NULL;
	HistoryEntry* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	GtkBox* vbox = NULL;
	GtkBox* _tmp7_ = NULL;
	GtkBox* _tmp8_ = NULL;
	GtkBox* _tmp9_ = NULL;
	GtkBox* _tmp10_ = NULL;
	GtkBox* _tmp11_ = NULL;
	GtkBox* hbox = NULL;
	GtkBox* _tmp12_ = NULL;
	GtkBox* _tmp13_ = NULL;
	GtkBox* _tmp14_ = NULL;
	GtkBox* _tmp15_ = NULL;
	GtkLabel* label = NULL;
	const gchar* _tmp16_ = NULL;
	GtkLabel* _tmp17_ = NULL;
	GtkLabel* _tmp18_ = NULL;
	GtkBox* _tmp19_ = NULL;
	GtkLabel* _tmp20_ = NULL;
	GtkListStore* _tmp21_ = NULL;
	GtkComboBox* _tmp22_ = NULL;
	GtkComboBox* _tmp23_ = NULL;
	GtkComboBox* _tmp24_ = NULL;
	GtkListStore* _tmp25_ = NULL;
	GtkCellRendererText* renderer = NULL;
	GtkCellRendererText* _tmp26_ = NULL;
	GtkComboBox* _tmp27_ = NULL;
	GtkCellRendererText* _tmp28_ = NULL;
	GtkComboBox* _tmp29_ = NULL;
	GtkCellRendererText* _tmp30_ = NULL;
	GtkComboBox* _tmp31_ = NULL;
	GtkBox* _tmp32_ = NULL;
	GtkComboBox* _tmp33_ = NULL;
	GtkScrolledWindow* scroll = NULL;
	GtkScrolledWindow* _tmp34_ = NULL;
	GtkScrolledWindow* _tmp35_ = NULL;
	GtkScrolledWindow* _tmp36_ = NULL;
	GtkScrolledWindow* _tmp37_ = NULL;
	GtkBox* _tmp38_ = NULL;
	GtkScrolledWindow* _tmp39_ = NULL;
	GtkListStore* _tmp40_ = NULL;
	GtkTreeView* scores = NULL;
	GtkTreeView* _tmp41_ = NULL;
	GtkCellRendererText* _tmp42_ = NULL;
	GtkTreeView* _tmp43_ = NULL;
	const gchar* _tmp44_ = NULL;
	GtkCellRendererText* _tmp45_ = NULL;
	GtkCellRendererText* _tmp46_ = NULL;
	GtkCellRendererText* _tmp47_ = NULL;
	GtkTreeView* _tmp48_ = NULL;
	const gchar* _tmp49_ = NULL;
	GtkCellRendererText* _tmp50_ = NULL;
	GtkTreeView* _tmp51_ = NULL;
	GtkListStore* _tmp52_ = NULL;
	GtkTreeView* _tmp53_ = NULL;
	GtkScrolledWindow* _tmp54_ = NULL;
	GtkTreeView* _tmp55_ = NULL;
	History* _tmp56_ = NULL;
	GList* _tmp57_ = NULL;
	g_return_val_if_fail (history != NULL, NULL);
	self = (ScoreDialog*) g_object_new (object_type, NULL);
	_tmp0_ = history;
	_tmp1_ = _history_ref0 (_tmp0_);
	_history_unref0 (self->priv->history);
	self->priv->history = _tmp1_;
	_tmp2_ = history;
	g_signal_connect_object (_tmp2_, "entry-added", (GCallback) _score_dialog_entry_added_cb_history_entry_added, self, 0);
	_tmp3_ = selected_entry;
	_tmp4_ = _history_entry_ref0 (_tmp3_);
	_history_entry_unref0 (self->priv->selected_entry);
	self->priv->selected_entry = _tmp4_;
	_tmp5_ = show_quit;
	if (_tmp5_) {
		const gchar* _tmp6_ = NULL;
		gtk_dialog_add_button ((GtkDialog*) self, GTK_STOCK_QUIT, (gint) GTK_RESPONSE_CLOSE);
		_tmp6_ = _ ("New Game");
		gtk_dialog_add_button ((GtkDialog*) self, _tmp6_, (gint) GTK_RESPONSE_OK);
	} else {
		gtk_dialog_add_button ((GtkDialog*) self, GTK_STOCK_OK, (gint) GTK_RESPONSE_DELETE_EVENT);
	}
	gtk_widget_set_size_request ((GtkWidget*) self, 200, 300);
	_tmp7_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 5);
	g_object_ref_sink (_tmp7_);
	vbox = _tmp7_;
	_tmp8_ = vbox;
	gtk_container_set_border_width ((GtkContainer*) _tmp8_, (guint) 6);
	_tmp9_ = vbox;
	gtk_widget_show ((GtkWidget*) _tmp9_);
	_tmp10_ = (GtkBox*) gtk_dialog_get_content_area ((GtkDialog*) self);
	_tmp11_ = vbox;
	gtk_box_pack_start (_tmp10_, (GtkWidget*) _tmp11_, TRUE, TRUE, (guint) 0);
	_tmp12_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
	g_object_ref_sink (_tmp12_);
	hbox = _tmp12_;
	_tmp13_ = hbox;
	gtk_widget_show ((GtkWidget*) _tmp13_);
	_tmp14_ = vbox;
	_tmp15_ = hbox;
	gtk_box_pack_start (_tmp14_, (GtkWidget*) _tmp15_, FALSE, FALSE, (guint) 0);
	_tmp16_ = _ ("Layout:");
	_tmp17_ = (GtkLabel*) gtk_label_new (_tmp16_);
	g_object_ref_sink (_tmp17_);
	label = _tmp17_;
	_tmp18_ = label;
	gtk_widget_show ((GtkWidget*) _tmp18_);
	_tmp19_ = hbox;
	_tmp20_ = label;
	gtk_box_pack_start (_tmp19_, (GtkWidget*) _tmp20_, FALSE, FALSE, (guint) 0);
	_tmp21_ = gtk_list_store_new (2, G_TYPE_STRING, G_TYPE_STRING);
	_g_object_unref0 (self->priv->size_model);
	self->priv->size_model = _tmp21_;
	_tmp22_ = (GtkComboBox*) gtk_combo_box_new ();
	g_object_ref_sink (_tmp22_);
	_g_object_unref0 (self->priv->size_combo);
	self->priv->size_combo = _tmp22_;
	_tmp23_ = self->priv->size_combo;
	g_signal_connect_object (_tmp23_, "changed", (GCallback) _score_dialog_size_changed_cb_gtk_combo_box_changed, self, 0);
	_tmp24_ = self->priv->size_combo;
	_tmp25_ = self->priv->size_model;
	gtk_combo_box_set_model (_tmp24_, (GtkTreeModel*) _tmp25_);
	_tmp26_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp26_);
	renderer = _tmp26_;
	_tmp27_ = self->priv->size_combo;
	_tmp28_ = renderer;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp27_, (GtkCellRenderer*) _tmp28_, TRUE);
	_tmp29_ = self->priv->size_combo;
	_tmp30_ = renderer;
	gtk_cell_layout_add_attribute ((GtkCellLayout*) _tmp29_, (GtkCellRenderer*) _tmp30_, "text", 0);
	_tmp31_ = self->priv->size_combo;
	gtk_widget_show ((GtkWidget*) _tmp31_);
	_tmp32_ = hbox;
	_tmp33_ = self->priv->size_combo;
	gtk_box_pack_start (_tmp32_, (GtkWidget*) _tmp33_, TRUE, TRUE, (guint) 0);
	_tmp34_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp34_);
	scroll = _tmp34_;
	_tmp35_ = scroll;
	gtk_scrolled_window_set_shadow_type (_tmp35_, GTK_SHADOW_ETCHED_IN);
	_tmp36_ = scroll;
	gtk_scrolled_window_set_policy (_tmp36_, GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
	_tmp37_ = scroll;
	gtk_widget_show ((GtkWidget*) _tmp37_);
	_tmp38_ = vbox;
	_tmp39_ = scroll;
	gtk_box_pack_start (_tmp38_, (GtkWidget*) _tmp39_, TRUE, TRUE, (guint) 0);
	_tmp40_ = gtk_list_store_new (3, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_INT);
	_g_object_unref0 (self->priv->score_model);
	self->priv->score_model = _tmp40_;
	_tmp41_ = (GtkTreeView*) gtk_tree_view_new ();
	g_object_ref_sink (_tmp41_);
	scores = _tmp41_;
	_tmp42_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp42_);
	_g_object_unref0 (renderer);
	renderer = _tmp42_;
	_tmp43_ = scores;
	_tmp44_ = _ ("Date");
	_tmp45_ = renderer;
	gtk_tree_view_insert_column_with_attributes (_tmp43_, -1, _tmp44_, (GtkCellRenderer*) _tmp45_, "text", 0, "weight", 2, NULL);
	_tmp46_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp46_);
	_g_object_unref0 (renderer);
	renderer = _tmp46_;
	_tmp47_ = renderer;
	g_object_set ((GtkCellRenderer*) _tmp47_, "xalign", 1.0f, NULL);
	_tmp48_ = scores;
	_tmp49_ = _ ("Time");
	_tmp50_ = renderer;
	gtk_tree_view_insert_column_with_attributes (_tmp48_, -1, _tmp49_, (GtkCellRenderer*) _tmp50_, "text", 1, "weight", 2, NULL);
	_tmp51_ = scores;
	_tmp52_ = self->priv->score_model;
	gtk_tree_view_set_model (_tmp51_, (GtkTreeModel*) _tmp52_);
	_tmp53_ = scores;
	gtk_widget_show ((GtkWidget*) _tmp53_);
	_tmp54_ = scroll;
	_tmp55_ = scores;
	gtk_container_add ((GtkContainer*) _tmp54_, (GtkWidget*) _tmp55_);
	_tmp56_ = history;
	_tmp57_ = _tmp56_->entries;
	{
		GList* entry_collection = NULL;
		GList* entry_it = NULL;
		entry_collection = _tmp57_;
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			HistoryEntry* _tmp58_ = NULL;
			HistoryEntry* entry = NULL;
			_tmp58_ = _history_entry_ref0 ((HistoryEntry*) entry_it->data);
			entry = _tmp58_;
			{
				HistoryEntry* _tmp59_ = NULL;
				_tmp59_ = entry;
				score_dialog_entry_added_cb (self, _tmp59_);
				_history_entry_unref0 (entry);
			}
		}
	}
	_g_object_unref0 (scores);
	_g_object_unref0 (scroll);
	_g_object_unref0 (renderer);
	_g_object_unref0 (label);
	_g_object_unref0 (hbox);
	_g_object_unref0 (vbox);
	return self;
}


ScoreDialog* score_dialog_new (History* history, HistoryEntry* selected_entry, gboolean show_quit) {
	return score_dialog_construct (TYPE_SCORE_DIALOG, history, selected_entry, show_quit);
}


static gint _score_dialog_compare_entries_gcompare_func (gconstpointer a, gconstpointer b) {
	gint result;
	result = score_dialog_compare_entries (a, b);
	return result;
}


void score_dialog_set_map (ScoreDialog* self, const gchar* name) {
	GtkListStore* _tmp0_ = NULL;
	GList* entries = NULL;
	History* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	GList* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (name != NULL);
	_tmp0_ = self->priv->score_model;
	gtk_list_store_clear (_tmp0_);
	_tmp1_ = self->priv->history;
	_tmp2_ = _tmp1_->entries;
	_tmp3_ = g_list_copy (_tmp2_);
	entries = _tmp3_;
	entries = g_list_sort (entries, _score_dialog_compare_entries_gcompare_func);
	_tmp4_ = entries;
	{
		GList* entry_collection = NULL;
		GList* entry_it = NULL;
		entry_collection = _tmp4_;
		for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
			HistoryEntry* entry = NULL;
			entry = (HistoryEntry*) entry_it->data;
			{
				HistoryEntry* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				const gchar* _tmp7_ = NULL;
				gchar* date_label = NULL;
				HistoryEntry* _tmp8_ = NULL;
				GDateTime* _tmp9_ = NULL;
				gchar* _tmp10_ = NULL;
				gchar* time_label = NULL;
				HistoryEntry* _tmp11_ = NULL;
				guint _tmp12_ = 0U;
				gchar* _tmp13_ = NULL;
				HistoryEntry* _tmp14_ = NULL;
				guint _tmp15_ = 0U;
				gint weight = 0;
				HistoryEntry* _tmp21_ = NULL;
				HistoryEntry* _tmp22_ = NULL;
				GtkTreeIter iter = {0};
				GtkListStore* _tmp23_ = NULL;
				GtkTreeIter _tmp24_ = {0};
				GtkListStore* _tmp25_ = NULL;
				GtkTreeIter _tmp26_ = {0};
				const gchar* _tmp27_ = NULL;
				const gchar* _tmp28_ = NULL;
				gint _tmp29_ = 0;
				_tmp5_ = entry;
				_tmp6_ = _tmp5_->name;
				_tmp7_ = name;
				if (g_strcmp0 (_tmp6_, _tmp7_) != 0) {
					continue;
				}
				_tmp8_ = entry;
				_tmp9_ = _tmp8_->date;
				_tmp10_ = g_date_time_format (_tmp9_, "%d/%m/%Y");
				date_label = _tmp10_;
				_tmp11_ = entry;
				_tmp12_ = _tmp11_->duration;
				_tmp13_ = g_strdup_printf ("%us", _tmp12_);
				time_label = _tmp13_;
				_tmp14_ = entry;
				_tmp15_ = _tmp14_->duration;
				if (_tmp15_ >= ((guint) 60)) {
					HistoryEntry* _tmp16_ = NULL;
					guint _tmp17_ = 0U;
					HistoryEntry* _tmp18_ = NULL;
					guint _tmp19_ = 0U;
					gchar* _tmp20_ = NULL;
					_tmp16_ = entry;
					_tmp17_ = _tmp16_->duration;
					_tmp18_ = entry;
					_tmp19_ = _tmp18_->duration;
					_tmp20_ = g_strdup_printf ("%um %us", _tmp17_ / 60, _tmp19_ % 60);
					_g_free0 (time_label);
					time_label = _tmp20_;
				}
				weight = (gint) PANGO_WEIGHT_NORMAL;
				_tmp21_ = entry;
				_tmp22_ = self->priv->selected_entry;
				if (_tmp21_ == _tmp22_) {
					weight = (gint) PANGO_WEIGHT_BOLD;
				}
				_tmp23_ = self->priv->score_model;
				gtk_list_store_append (_tmp23_, &_tmp24_);
				iter = _tmp24_;
				_tmp25_ = self->priv->score_model;
				_tmp26_ = iter;
				_tmp27_ = date_label;
				_tmp28_ = time_label;
				_tmp29_ = weight;
				gtk_list_store_set (_tmp25_, &_tmp26_, 0, _tmp27_, 1, _tmp28_, 2, _tmp29_, -1);
				_g_free0 (time_label);
				_g_free0 (date_label);
			}
		}
	}
	_g_list_free0 (entries);
}


static gint score_dialog_compare_entries (HistoryEntry* a, HistoryEntry* b) {
	gint result = 0;
	gint d = 0;
	GCompareFunc _tmp0_ = NULL;
	HistoryEntry* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	HistoryEntry* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	HistoryEntry* _tmp7_ = NULL;
	guint _tmp8_ = 0U;
	HistoryEntry* _tmp9_ = NULL;
	guint _tmp10_ = 0U;
	HistoryEntry* _tmp15_ = NULL;
	GDateTime* _tmp16_ = NULL;
	HistoryEntry* _tmp17_ = NULL;
	GDateTime* _tmp18_ = NULL;
	gint _tmp19_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = g_strcmp0;
	_tmp1_ = a;
	_tmp2_ = _tmp1_->name;
	_tmp3_ = b;
	_tmp4_ = _tmp3_->name;
	_tmp5_ = _tmp0_ (_tmp2_, _tmp4_);
	d = _tmp5_;
	_tmp6_ = d;
	if (_tmp6_ != 0) {
		result = d;
		return result;
	}
	_tmp7_ = a;
	_tmp8_ = _tmp7_->duration;
	_tmp9_ = b;
	_tmp10_ = _tmp9_->duration;
	if (_tmp8_ != _tmp10_) {
		HistoryEntry* _tmp11_ = NULL;
		guint _tmp12_ = 0U;
		HistoryEntry* _tmp13_ = NULL;
		guint _tmp14_ = 0U;
		_tmp11_ = a;
		_tmp12_ = _tmp11_->duration;
		_tmp13_ = b;
		_tmp14_ = _tmp13_->duration;
		result = ((gint) _tmp12_) - ((gint) _tmp14_);
		return result;
	}
	_tmp15_ = a;
	_tmp16_ = _tmp15_->date;
	_tmp17_ = b;
	_tmp18_ = _tmp17_->date;
	_tmp19_ = g_date_time_compare (_tmp16_, _tmp18_);
	result = _tmp19_;
	return result;
}


static void score_dialog_size_changed_cb (ScoreDialog* self, GtkComboBox* combo) {
	GtkTreeIter iter = {0};
	GtkComboBox* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_ = FALSE;
	gchar* name = NULL;
	GtkComboBox* _tmp3_ = NULL;
	GtkTreeModel* _tmp4_ = NULL;
	GtkTreeModel* _tmp5_ = NULL;
	GtkTreeIter _tmp6_ = {0};
	const gchar* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (combo != NULL);
	_tmp0_ = combo;
	_tmp2_ = gtk_combo_box_get_active_iter (_tmp0_, &_tmp1_);
	iter = _tmp1_;
	if (!_tmp2_) {
		return;
	}
	_tmp3_ = combo;
	_tmp4_ = gtk_combo_box_get_model (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = iter;
	gtk_tree_model_get (_tmp5_, &_tmp6_, 1, &name, -1);
	_tmp7_ = name;
	score_dialog_set_map (self, _tmp7_);
	_g_free0 (name);
}


static void score_dialog_entry_added_cb (ScoreDialog* self, HistoryEntry* entry) {
	GtkTreeIter iter = {0};
	gboolean have_size_entry = FALSE;
	GtkListStore* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	gboolean _tmp2_ = FALSE;
	gboolean _tmp12_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (entry != NULL);
	have_size_entry = FALSE;
	_tmp0_ = self->priv->size_model;
	_tmp2_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) _tmp0_, &_tmp1_);
	iter = _tmp1_;
	if (_tmp2_) {
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_ = FALSE;
				gchar* name = NULL;
				GtkListStore* _tmp7_ = NULL;
				GtkTreeIter _tmp8_ = {0};
				const gchar* _tmp9_ = NULL;
				HistoryEntry* _tmp10_ = NULL;
				const gchar* _tmp11_ = NULL;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					GtkListStore* _tmp5_ = NULL;
					gboolean _tmp6_ = FALSE;
					_tmp5_ = self->priv->size_model;
					_tmp6_ = gtk_tree_model_iter_next ((GtkTreeModel*) _tmp5_, &iter);
					if (!_tmp6_) {
						break;
					}
				}
				_tmp3_ = FALSE;
				_tmp7_ = self->priv->size_model;
				_tmp8_ = iter;
				gtk_tree_model_get ((GtkTreeModel*) _tmp7_, &_tmp8_, 1, &name, -1);
				_tmp9_ = name;
				_tmp10_ = entry;
				_tmp11_ = _tmp10_->name;
				if (g_strcmp0 (_tmp9_, _tmp11_) == 0) {
					have_size_entry = TRUE;
					_g_free0 (name);
					break;
				}
				_g_free0 (name);
			}
		}
	}
	_tmp12_ = have_size_entry;
	if (!_tmp12_) {
		gchar* label = NULL;
		HistoryEntry* _tmp13_ = NULL;
		const gchar* _tmp14_ = NULL;
		gchar* _tmp15_ = NULL;
		GtkListStore* _tmp16_ = NULL;
		GtkTreeIter _tmp17_ = {0};
		GtkListStore* _tmp18_ = NULL;
		GtkTreeIter _tmp19_ = {0};
		const gchar* _tmp20_ = NULL;
		HistoryEntry* _tmp21_ = NULL;
		const gchar* _tmp22_ = NULL;
		GtkComboBox* _tmp23_ = NULL;
		gint _tmp24_ = 0;
		gboolean _tmp27_ = FALSE;
		HistoryEntry* _tmp28_ = NULL;
		gboolean _tmp33_ = FALSE;
		_tmp13_ = entry;
		_tmp14_ = _tmp13_->name;
		_tmp15_ = g_strdup_printf ("%s", _tmp14_);
		label = _tmp15_;
		_tmp16_ = self->priv->size_model;
		gtk_list_store_append (_tmp16_, &_tmp17_);
		iter = _tmp17_;
		_tmp18_ = self->priv->size_model;
		_tmp19_ = iter;
		_tmp20_ = label;
		_tmp21_ = entry;
		_tmp22_ = _tmp21_->name;
		gtk_list_store_set (_tmp18_, &_tmp19_, 0, _tmp20_, 1, _tmp22_, -1);
		_tmp23_ = self->priv->size_combo;
		_tmp24_ = gtk_combo_box_get_active (_tmp23_);
		if (_tmp24_ == (-1)) {
			GtkComboBox* _tmp25_ = NULL;
			GtkTreeIter _tmp26_ = {0};
			_tmp25_ = self->priv->size_combo;
			_tmp26_ = iter;
			gtk_combo_box_set_active_iter (_tmp25_, &_tmp26_);
		}
		_tmp28_ = self->priv->selected_entry;
		if (_tmp28_ != NULL) {
			HistoryEntry* _tmp29_ = NULL;
			const gchar* _tmp30_ = NULL;
			HistoryEntry* _tmp31_ = NULL;
			const gchar* _tmp32_ = NULL;
			_tmp29_ = entry;
			_tmp30_ = _tmp29_->name;
			_tmp31_ = self->priv->selected_entry;
			_tmp32_ = _tmp31_->name;
			_tmp27_ = g_strcmp0 (_tmp30_, _tmp32_) == 0;
		} else {
			_tmp27_ = FALSE;
		}
		_tmp33_ = _tmp27_;
		if (_tmp33_) {
			GtkComboBox* _tmp34_ = NULL;
			GtkTreeIter _tmp35_ = {0};
			_tmp34_ = self->priv->size_combo;
			_tmp35_ = iter;
			gtk_combo_box_set_active_iter (_tmp34_, &_tmp35_);
		}
		_g_free0 (label);
	}
}


static void score_dialog_class_init (ScoreDialogClass * klass) {
	score_dialog_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ScoreDialogPrivate));
	G_OBJECT_CLASS (klass)->finalize = score_dialog_finalize;
}


static void score_dialog_instance_init (ScoreDialog * self) {
	self->priv = SCORE_DIALOG_GET_PRIVATE (self);
	self->priv->selected_entry = NULL;
}


static void score_dialog_finalize (GObject* obj) {
	ScoreDialog * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCORE_DIALOG, ScoreDialog);
	_history_unref0 (self->priv->history);
	_history_entry_unref0 (self->priv->selected_entry);
	_g_object_unref0 (self->priv->size_model);
	_g_object_unref0 (self->priv->score_model);
	_g_object_unref0 (self->priv->size_combo);
	G_OBJECT_CLASS (score_dialog_parent_class)->finalize (obj);
}


GType score_dialog_get_type (void) {
	static volatile gsize score_dialog_type_id__volatile = 0;
	if (g_once_init_enter (&score_dialog_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ScoreDialogClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) score_dialog_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ScoreDialog), 0, (GInstanceInitFunc) score_dialog_instance_init, NULL };
		GType score_dialog_type_id;
		score_dialog_type_id = g_type_register_static (GTK_TYPE_DIALOG, "ScoreDialog", &g_define_type_info, 0);
		g_once_init_leave (&score_dialog_type_id__volatile, score_dialog_type_id);
	}
	return score_dialog_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



