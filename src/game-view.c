/* game-view.c generated by valac 0.22.1, the Vala compiler
 * generated from game-view.vala, do not modify */

/*
 * Copyright (C) 2010-2013 Robert Ancell
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 2 of the License, or (at your option) any later
 * version. See http://www.gnu.org/copyleft/gpl.html the full text of the
 * license.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <cairo.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <glib/gi18n-lib.h>
#include <librsvg/rsvg.h>


#define TYPE_GAME_VIEW (game_view_get_type ())
#define GAME_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME_VIEW, GameView))
#define GAME_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME_VIEW, GameViewClass))
#define IS_GAME_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME_VIEW))
#define IS_GAME_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME_VIEW))
#define GAME_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME_VIEW, GameViewClass))

typedef struct _GameView GameView;
typedef struct _GameViewClass GameViewClass;
typedef struct _GameViewPrivate GameViewPrivate;

#define TYPE_GAME (game_get_type ())
#define GAME(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GAME, Game))
#define GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GAME, GameClass))
#define IS_GAME(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GAME))
#define IS_GAME_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GAME))
#define GAME_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GAME, GameClass))

typedef struct _Game Game;
typedef struct _GameClass GameClass;
#define _cairo_pattern_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_pattern_destroy (var), NULL)))
#define _game_unref0(var) ((var == NULL) ? NULL : (var = (game_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
typedef struct _GamePrivate GamePrivate;

#define TYPE_MAP (map_get_type ())
#define MAP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAP, Map))
#define MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAP, MapClass))
#define IS_MAP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAP))
#define IS_MAP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAP))
#define MAP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAP, MapClass))

typedef struct _Map Map;
typedef struct _MapClass MapClass;

#define TYPE_TILE (tile_get_type ())
#define TILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TILE, Tile))
#define TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TILE, TileClass))
#define IS_TILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TILE))
#define IS_TILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TILE))
#define TILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TILE, TileClass))

typedef struct _Tile Tile;
typedef struct _TileClass TileClass;
typedef struct _TilePrivate TilePrivate;

#define TYPE_SLOT (slot_get_type ())
#define SLOT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SLOT, Slot))
#define SLOT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SLOT, SlotClass))
#define IS_SLOT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SLOT))
#define IS_SLOT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SLOT))
#define SLOT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SLOT, SlotClass))

typedef struct _Slot Slot;
typedef struct _SlotClass SlotClass;
#define _tile_unref0(var) ((var == NULL) ? NULL : (var = (tile_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _SlotPrivate SlotPrivate;

struct _GameView {
	GtkDrawingArea parent_instance;
	GameViewPrivate * priv;
	GdkRGBA background_color;
	gboolean auto_play;
};

struct _GameViewClass {
	GtkDrawingAreaClass parent_class;
};

struct _GameViewPrivate {
	cairo_pattern_t* tile_pattern;
	gint tile_pattern_width;
	gint tile_pattern_height;
	gint x_offset;
	gint y_offset;
	gint tile_width;
	gint tile_height;
	gint tile_layer_offset_x;
	gint tile_layer_offset_y;
	Game* _game;
	gchar* _theme;
};

struct _Game {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GamePrivate * priv;
	Map* map;
	GList* tiles;
	Tile* hint_tiles[2];
	GList** sets;
	gint sets_length1;
	gint move_number;
	guint hint_blink_counter;
};

struct _GameClass {
	GTypeClass parent_class;
	void (*finalize) (Game *self);
};

struct _Tile {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TilePrivate * priv;
	gint number;
	Slot* slot;
	gboolean visible;
	gint move_number;
};

struct _TileClass {
	GTypeClass parent_class;
	void (*finalize) (Tile *self);
};

struct _Slot {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SlotPrivate * priv;
	gint x;
	gint y;
	gint layer;
};

struct _SlotClass {
	GTypeClass parent_class;
	void (*finalize) (Slot *self);
};


static gpointer game_view_parent_class = NULL;

GType game_view_get_type (void) G_GNUC_CONST;
gpointer game_ref (gpointer instance);
void game_unref (gpointer instance);
GParamSpec* param_spec_game (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_game (GValue* value, gpointer v_object);
void value_take_game (GValue* value, gpointer v_object);
gpointer value_get_game (const GValue* value);
GType game_get_type (void) G_GNUC_CONST;
#define GAME_VIEW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_GAME_VIEW, GameViewPrivate))
enum  {
	GAME_VIEW_DUMMY_PROPERTY,
	GAME_VIEW_GAME,
	GAME_VIEW_THEME
};
GameView* game_view_new (void);
GameView* game_view_construct (GType object_type);
void game_view_set_background (GameView* self, const gchar* colour);
static void game_view_draw_game (GameView* self, cairo_t* cr, gboolean render_indexes);
const gchar* game_view_get_theme (GameView* self);
static void game_view_update_dimensions (GameView* self);
static GdkPixbuf* game_view_load_theme (GameView* self, gint width, gint height);
Game* game_view_get_game (GameView* self);
gpointer map_ref (gpointer instance);
void map_unref (gpointer instance);
GParamSpec* param_spec_map (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_map (GValue* value, gpointer v_object);
void value_take_map (GValue* value, gpointer v_object);
gpointer value_get_map (const GValue* value);
GType map_get_type (void) G_GNUC_CONST;
gpointer tile_ref (gpointer instance);
void tile_unref (gpointer instance);
GParamSpec* param_spec_tile (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_tile (GValue* value, gpointer v_object);
void value_take_tile (GValue* value, gpointer v_object);
gpointer value_get_tile (const GValue* value);
GType tile_get_type (void) G_GNUC_CONST;
gpointer slot_ref (gpointer instance);
void slot_unref (gpointer instance);
GParamSpec* param_spec_slot (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_slot (GValue* value, gpointer v_object);
void value_take_slot (GValue* value, gpointer v_object);
gpointer value_get_slot (const GValue* value);
GType slot_get_type (void) G_GNUC_CONST;
static void game_view_get_tile_position (GameView* self, Tile* tile, gint* x, gint* y);
static gint game_view_get_image_offset (GameView* self, gint number);
gboolean game_get_paused (Game* self);
Tile* game_get_selected_tile (Game* self);
static gboolean game_view_get_theme_dimensions (GameView* self, gint* width, gint* height);
guint map_get_width (Map* self);
guint map_get_height (Map* self);
static void game_view_redraw_tile_cb (GameView* self, Tile* tile);
static void game_view_paused_changed_cb (GameView* self);
static gboolean game_view_real_draw (GtkWidget* base, cairo_t* cr);
static gboolean game_view_real_button_press_event (GtkWidget* base, GdkEventButton* event);
static Tile* game_view_find_tile (GameView* self, guint x, guint y);
gboolean game_tile_can_move (Game* self, Tile* tile);
void game_set_selected_tile (Game* self, Tile* value);
gboolean tile_matches (Tile* self, Tile* tile);
gboolean game_remove_pair (Game* self, Tile* tile0, Tile* tile1);
void game_auto_move (Game* self);
void game_view_set_game (GameView* self, Game* value);
static void _game_view_redraw_tile_cb_game_redraw_tile (Game* _sender, Tile* tile, gpointer self);
static void _game_view_paused_changed_cb_game_paused_changed (Game* _sender, gpointer self);
void game_view_set_theme (GameView* self, const gchar* value);
static void game_view_finalize (GObject* obj);
static void _vala_game_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_game_view_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


GameView* game_view_construct (GType object_type) {
	GameView * self = NULL;
	self = (GameView*) g_object_new (object_type, NULL);
	g_object_set ((GtkWidget*) self, "can-focus", TRUE, NULL);
	gtk_widget_add_events ((GtkWidget*) self, (gint) GDK_BUTTON_PRESS_MASK);
	return self;
}


GameView* game_view_new (void) {
	return game_view_construct (TYPE_GAME_VIEW);
}


void game_view_set_background (GameView* self, const gchar* colour) {
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	memset (&self->background_color, 0, sizeof (GdkRGBA));
	_tmp1_ = colour;
	if (_tmp1_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		const gchar* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = colour;
		_tmp3_ = gdk_rgba_parse (&self->background_color, _tmp2_);
		_tmp0_ = !_tmp3_;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		gdouble _tmp5_ = 0.0;
		gdouble _tmp6_ = 0.0;
		self->background_color.blue = (gdouble) 0;
		_tmp5_ = self->background_color.blue;
		self->background_color.green = _tmp5_;
		_tmp6_ = self->background_color.green;
		self->background_color.red = _tmp6_;
	}
	gtk_widget_queue_draw ((GtkWidget*) self);
}


static gpointer _tile_ref0 (gpointer self) {
	return self ? tile_ref (self) : NULL;
}


static void game_view_draw_game (GameView* self, cairo_t* cr, gboolean render_indexes) {
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gint image_width = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint image_height = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp17_ = FALSE;
	Game* _tmp38_ = NULL;
	Game* _tmp39_ = NULL;
	GList* _tmp40_ = NULL;
	Game* _tmp101_ = NULL;
	Game* _tmp102_ = NULL;
	gboolean _tmp103_ = FALSE;
	gboolean _tmp104_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cr != NULL);
	_tmp0_ = game_view_get_theme (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ == NULL) {
		return;
	}
	game_view_update_dimensions (self);
	_tmp2_ = self->priv->tile_width;
	_tmp3_ = self->priv->tile_layer_offset_x;
	image_width = _tmp2_ + _tmp3_;
	_tmp4_ = self->priv->tile_height;
	_tmp5_ = self->priv->tile_layer_offset_y;
	image_height = _tmp4_ + _tmp5_;
	_tmp7_ = render_indexes;
	if (!_tmp7_) {
		gboolean _tmp8_ = FALSE;
		gboolean _tmp9_ = FALSE;
		cairo_pattern_t* _tmp10_ = NULL;
		gboolean _tmp13_ = FALSE;
		gboolean _tmp16_ = FALSE;
		_tmp10_ = self->priv->tile_pattern;
		if (_tmp10_ == NULL) {
			_tmp9_ = TRUE;
		} else {
			gint _tmp11_ = 0;
			gint _tmp12_ = 0;
			_tmp11_ = self->priv->tile_pattern_width;
			_tmp12_ = image_width;
			_tmp9_ = _tmp11_ != _tmp12_;
		}
		_tmp13_ = _tmp9_;
		if (_tmp13_) {
			_tmp8_ = TRUE;
		} else {
			gint _tmp14_ = 0;
			gint _tmp15_ = 0;
			_tmp14_ = self->priv->tile_pattern_height;
			_tmp15_ = image_height;
			_tmp8_ = _tmp14_ != _tmp15_;
		}
		_tmp16_ = _tmp8_;
		_tmp6_ = _tmp16_;
	} else {
		_tmp6_ = FALSE;
	}
	_tmp17_ = _tmp6_;
	if (_tmp17_) {
		gint _tmp18_ = 0;
		gint _tmp19_ = 0;
		gint width = 0;
		gint _tmp20_ = 0;
		gint height = 0;
		gint _tmp21_ = 0;
		cairo_surface_t* surface = NULL;
		cairo_t* _tmp22_ = NULL;
		cairo_surface_t* _tmp23_ = NULL;
		gint _tmp24_ = 0;
		gint _tmp25_ = 0;
		cairo_surface_t* _tmp26_ = NULL;
		cairo_t* c = NULL;
		cairo_surface_t* _tmp27_ = NULL;
		cairo_t* _tmp28_ = NULL;
		GdkPixbuf* pixbuf = NULL;
		gint _tmp29_ = 0;
		gint _tmp30_ = 0;
		GdkPixbuf* _tmp31_ = NULL;
		GdkPixbuf* _tmp32_ = NULL;
		cairo_t* _tmp33_ = NULL;
		GdkPixbuf* _tmp34_ = NULL;
		cairo_t* _tmp35_ = NULL;
		cairo_surface_t* _tmp36_ = NULL;
		cairo_pattern_t* _tmp37_ = NULL;
		_tmp18_ = image_width;
		self->priv->tile_pattern_width = _tmp18_;
		_tmp19_ = image_height;
		self->priv->tile_pattern_height = _tmp19_;
		_tmp20_ = image_width;
		width = _tmp20_ * 43;
		_tmp21_ = image_height;
		height = _tmp21_ * 2;
		_tmp22_ = cr;
		_tmp23_ = cairo_get_target (_tmp22_);
		_tmp24_ = width;
		_tmp25_ = height;
		_tmp26_ = cairo_surface_create_similar (_tmp23_, CAIRO_CONTENT_COLOR_ALPHA, _tmp24_, _tmp25_);
		surface = _tmp26_;
		_tmp27_ = surface;
		_tmp28_ = cairo_create (_tmp27_);
		c = _tmp28_;
		_tmp29_ = width;
		_tmp30_ = height;
		_tmp31_ = game_view_load_theme (self, _tmp29_, _tmp30_);
		pixbuf = _tmp31_;
		_tmp32_ = pixbuf;
		if (_tmp32_ == NULL) {
			_g_object_unref0 (pixbuf);
			_cairo_destroy0 (c);
			_cairo_surface_destroy0 (surface);
			return;
		}
		_tmp33_ = c;
		_tmp34_ = pixbuf;
		gdk_cairo_set_source_pixbuf (_tmp33_, _tmp34_, (gdouble) 0, (gdouble) 0);
		_tmp35_ = c;
		cairo_paint (_tmp35_);
		_tmp36_ = surface;
		_tmp37_ = cairo_pattern_create_for_surface (_tmp36_);
		_cairo_pattern_destroy0 (self->priv->tile_pattern);
		self->priv->tile_pattern = _tmp37_;
		_g_object_unref0 (pixbuf);
		_cairo_destroy0 (c);
		_cairo_surface_destroy0 (surface);
	}
	_tmp38_ = game_view_get_game (self);
	_tmp39_ = _tmp38_;
	_tmp40_ = _tmp39_->tiles;
	{
		GList* tile_collection = NULL;
		GList* tile_it = NULL;
		tile_collection = _tmp40_;
		for (tile_it = tile_collection; tile_it != NULL; tile_it = tile_it->next) {
			Tile* _tmp41_ = NULL;
			Tile* tile = NULL;
			_tmp41_ = _tile_ref0 ((Tile*) tile_it->data);
			tile = _tmp41_;
			{
				Tile* _tmp42_ = NULL;
				gboolean _tmp43_ = FALSE;
				gint x = 0;
				gint y = 0;
				Tile* _tmp44_ = NULL;
				gint _tmp45_ = 0;
				gint _tmp46_ = 0;
				gint texture_x = 0;
				Tile* _tmp47_ = NULL;
				gint _tmp48_ = 0;
				gint _tmp49_ = 0;
				gint _tmp50_ = 0;
				gint texture_y = 0;
				Game* _tmp51_ = NULL;
				Game* _tmp52_ = NULL;
				gboolean _tmp53_ = FALSE;
				gboolean _tmp54_ = FALSE;
				gboolean _tmp79_ = FALSE;
				cairo_t* _tmp95_ = NULL;
				gint _tmp96_ = 0;
				gint _tmp97_ = 0;
				gint _tmp98_ = 0;
				gint _tmp99_ = 0;
				cairo_t* _tmp100_ = NULL;
				_tmp42_ = tile;
				_tmp43_ = _tmp42_->visible;
				if (!_tmp43_) {
					_tile_unref0 (tile);
					continue;
				}
				_tmp44_ = tile;
				game_view_get_tile_position (self, _tmp44_, &_tmp45_, &_tmp46_);
				x = _tmp45_;
				y = _tmp46_;
				_tmp47_ = tile;
				_tmp48_ = _tmp47_->number;
				_tmp49_ = game_view_get_image_offset (self, _tmp48_);
				_tmp50_ = image_width;
				texture_x = _tmp49_ * _tmp50_;
				texture_y = 0;
				_tmp51_ = game_view_get_game (self);
				_tmp52_ = _tmp51_;
				_tmp53_ = game_get_paused (_tmp52_);
				_tmp54_ = _tmp53_;
				if (_tmp54_) {
					gint _tmp55_ = 0;
					gint _tmp56_ = 0;
					_tmp55_ = game_view_get_image_offset (self, -1);
					_tmp56_ = image_width;
					texture_x = _tmp55_ * _tmp56_;
					texture_y = 0;
				} else {
					Tile* _tmp57_ = NULL;
					Game* _tmp58_ = NULL;
					Game* _tmp59_ = NULL;
					Tile* _tmp60_ = NULL;
					Tile* _tmp61_ = NULL;
					_tmp57_ = tile;
					_tmp58_ = game_view_get_game (self);
					_tmp59_ = _tmp58_;
					_tmp60_ = game_get_selected_tile (_tmp59_);
					_tmp61_ = _tmp60_;
					if (_tmp57_ == _tmp61_) {
						gint _tmp62_ = 0;
						_tmp62_ = image_height;
						texture_y = _tmp62_;
					} else {
						gboolean _tmp63_ = FALSE;
						Game* _tmp64_ = NULL;
						Game* _tmp65_ = NULL;
						guint _tmp66_ = 0U;
						gboolean _tmp77_ = FALSE;
						_tmp64_ = game_view_get_game (self);
						_tmp65_ = _tmp64_;
						_tmp66_ = _tmp65_->hint_blink_counter;
						if ((_tmp66_ % 2) == ((guint) 1)) {
							gboolean _tmp67_ = FALSE;
							Tile* _tmp68_ = NULL;
							Game* _tmp69_ = NULL;
							Game* _tmp70_ = NULL;
							Tile* _tmp71_ = NULL;
							gboolean _tmp76_ = FALSE;
							_tmp68_ = tile;
							_tmp69_ = game_view_get_game (self);
							_tmp70_ = _tmp69_;
							_tmp71_ = _tmp70_->hint_tiles[0];
							if (_tmp68_ == _tmp71_) {
								_tmp67_ = TRUE;
							} else {
								Tile* _tmp72_ = NULL;
								Game* _tmp73_ = NULL;
								Game* _tmp74_ = NULL;
								Tile* _tmp75_ = NULL;
								_tmp72_ = tile;
								_tmp73_ = game_view_get_game (self);
								_tmp74_ = _tmp73_;
								_tmp75_ = _tmp74_->hint_tiles[1];
								_tmp67_ = _tmp72_ == _tmp75_;
							}
							_tmp76_ = _tmp67_;
							_tmp63_ = _tmp76_;
						} else {
							_tmp63_ = FALSE;
						}
						_tmp77_ = _tmp63_;
						if (_tmp77_) {
							gint _tmp78_ = 0;
							_tmp78_ = image_height;
							texture_y = _tmp78_;
						}
					}
				}
				_tmp79_ = render_indexes;
				if (_tmp79_) {
					cairo_t* _tmp80_ = NULL;
					Tile* _tmp81_ = NULL;
					gint _tmp82_ = 0;
					Tile* _tmp83_ = NULL;
					gint _tmp84_ = 0;
					Tile* _tmp85_ = NULL;
					gint _tmp86_ = 0;
					_tmp80_ = cr;
					_tmp81_ = tile;
					_tmp82_ = _tmp81_->number;
					_tmp83_ = tile;
					_tmp84_ = _tmp83_->number;
					_tmp85_ = tile;
					_tmp86_ = _tmp85_->number;
					cairo_set_source_rgb (_tmp80_, _tmp82_ / 255.0, _tmp84_ / 255.0, _tmp86_ / 255.0);
				} else {
					cairo_matrix_t matrix = {0};
					gint _tmp87_ = 0;
					gint _tmp88_ = 0;
					gint _tmp89_ = 0;
					gint _tmp90_ = 0;
					cairo_pattern_t* _tmp91_ = NULL;
					cairo_matrix_t _tmp92_ = {0};
					cairo_t* _tmp93_ = NULL;
					cairo_pattern_t* _tmp94_ = NULL;
					cairo_matrix_init_identity (&matrix);
					_tmp87_ = texture_x;
					_tmp88_ = x;
					_tmp89_ = texture_y;
					_tmp90_ = y;
					cairo_matrix_translate (&matrix, (gdouble) (_tmp87_ - _tmp88_), (gdouble) (_tmp89_ - _tmp90_));
					_tmp91_ = self->priv->tile_pattern;
					_tmp92_ = matrix;
					cairo_pattern_set_matrix (_tmp91_, &_tmp92_);
					_tmp93_ = cr;
					_tmp94_ = self->priv->tile_pattern;
					cairo_set_source (_tmp93_, _tmp94_);
				}
				_tmp95_ = cr;
				_tmp96_ = x;
				_tmp97_ = y;
				_tmp98_ = image_width;
				_tmp99_ = image_height;
				cairo_rectangle (_tmp95_, (gdouble) _tmp96_, (gdouble) _tmp97_, (gdouble) _tmp98_, (gdouble) _tmp99_);
				_tmp100_ = cr;
				cairo_fill (_tmp100_);
				_tile_unref0 (tile);
			}
		}
	}
	_tmp101_ = game_view_get_game (self);
	_tmp102_ = _tmp101_;
	_tmp103_ = game_get_paused (_tmp102_);
	_tmp104_ = _tmp103_;
	if (_tmp104_) {
		cairo_t* _tmp105_ = NULL;
		cairo_t* _tmp106_ = NULL;
		cairo_t* _tmp107_ = NULL;
		cairo_t* _tmp108_ = NULL;
		gint _tmp109_ = 0;
		gchar* text = NULL;
		const gchar* _tmp110_ = NULL;
		gchar* _tmp111_ = NULL;
		cairo_text_extents_t extents = {0};
		cairo_t* _tmp112_ = NULL;
		const gchar* _tmp113_ = NULL;
		cairo_text_extents_t _tmp114_ = {0};
		cairo_t* _tmp115_ = NULL;
		gint _tmp116_ = 0;
		cairo_text_extents_t _tmp117_ = {0};
		gdouble _tmp118_ = 0.0;
		gint _tmp119_ = 0;
		cairo_text_extents_t _tmp120_ = {0};
		gdouble _tmp121_ = 0.0;
		cairo_t* _tmp122_ = NULL;
		cairo_t* _tmp123_ = NULL;
		const gchar* _tmp124_ = NULL;
		_tmp105_ = cr;
		cairo_set_source_rgba (_tmp105_, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.75);
		_tmp106_ = cr;
		cairo_paint (_tmp106_);
		_tmp107_ = cr;
		cairo_select_font_face (_tmp107_, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);
		_tmp108_ = cr;
		_tmp109_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
		cairo_set_font_size (_tmp108_, _tmp109_ * 0.125);
		_tmp110_ = _ ("Paused");
		_tmp111_ = g_strdup (_tmp110_);
		text = _tmp111_;
		_tmp112_ = cr;
		_tmp113_ = text;
		cairo_text_extents (_tmp112_, _tmp113_, &_tmp114_);
		extents = _tmp114_;
		_tmp115_ = cr;
		_tmp116_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
		_tmp117_ = extents;
		_tmp118_ = _tmp117_.width;
		_tmp119_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
		_tmp120_ = extents;
		_tmp121_ = _tmp120_.height;
		cairo_move_to (_tmp115_, (_tmp116_ - _tmp118_) / 2.0, (_tmp119_ + _tmp121_) / 2.0);
		_tmp122_ = cr;
		cairo_set_source_rgb (_tmp122_, (gdouble) 1, (gdouble) 1, (gdouble) 1);
		_tmp123_ = cr;
		_tmp124_ = text;
		cairo_show_text (_tmp123_, _tmp124_);
		_g_free0 (text);
	}
}


static GdkPixbuf* game_view_load_theme (GameView* self, gint width, gint height) {
	GdkPixbuf* result = NULL;
	gint _tmp12_ = 0;
	gint _tmp13_ = 0;
	GdkPixbuf* _tmp14_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		GdkPixbuf* _tmp0_ = NULL;
		const gchar* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		GdkPixbuf* _tmp5_ = NULL;
		_tmp1_ = game_view_get_theme (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = width;
		_tmp4_ = height;
		_tmp5_ = rsvg_pixbuf_from_file_at_size (_tmp2_, _tmp3_, _tmp4_, &_inner_error_);
		_tmp0_ = _tmp5_;
		if (_inner_error_ != NULL) {
			goto __catch0_g_error;
		}
		result = _tmp0_;
		return result;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	{
		GdkPixbuf* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		gint _tmp10_ = 0;
		GdkPixbuf* _tmp11_ = NULL;
		_tmp7_ = game_view_get_theme (self);
		_tmp8_ = _tmp7_;
		_tmp9_ = width;
		_tmp10_ = height;
		_tmp11_ = gdk_pixbuf_new_from_file_at_scale (_tmp8_, _tmp9_, _tmp10_, FALSE, &_inner_error_);
		_tmp6_ = _tmp11_;
		if (_inner_error_ != NULL) {
			goto __catch1_g_error;
		}
		result = _tmp6_;
		return result;
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp12_ = width;
	_tmp13_ = height;
	_tmp14_ = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, _tmp12_, _tmp13_);
	result = _tmp14_;
	return result;
}


static void game_view_update_dimensions (GameView* self) {
	gint width = 0;
	gint _tmp0_ = 0;
	gint height = 0;
	gint _tmp1_ = 0;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gint theme_width = 0;
	gint theme_height = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gboolean _tmp6_ = FALSE;
	gdouble aspect = 0.0;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	gdouble map_width = 0.0;
	Game* _tmp9_ = NULL;
	Game* _tmp10_ = NULL;
	Map* _tmp11_ = NULL;
	guint _tmp12_ = 0U;
	guint _tmp13_ = 0U;
	gdouble map_height = 0.0;
	Game* _tmp14_ = NULL;
	Game* _tmp15_ = NULL;
	Map* _tmp16_ = NULL;
	guint _tmp17_ = 0U;
	guint _tmp18_ = 0U;
	gdouble _tmp19_ = 0.0;
	gdouble unit_width = 0.0;
	gint _tmp20_ = 0;
	gdouble _tmp21_ = 0.0;
	gint _tmp22_ = 0;
	gdouble _tmp23_ = 0.0;
	gdouble _tmp24_ = 0.0;
	gdouble unit_height = 0.0;
	gdouble _tmp25_ = 0.0;
	gdouble _tmp26_ = 0.0;
	gdouble _tmp27_ = 0.0;
	gdouble _tmp28_ = 0.0;
	gint _tmp29_ = 0;
	gint _tmp30_ = 0;
	gint _tmp31_ = 0;
	Game* _tmp32_ = NULL;
	Game* _tmp33_ = NULL;
	Map* _tmp34_ = NULL;
	guint _tmp35_ = 0U;
	guint _tmp36_ = 0U;
	gdouble _tmp37_ = 0.0;
	gint _tmp38_ = 0;
	Game* _tmp39_ = NULL;
	Game* _tmp40_ = NULL;
	Map* _tmp41_ = NULL;
	guint _tmp42_ = 0U;
	guint _tmp43_ = 0U;
	gdouble _tmp44_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
	width = _tmp0_;
	_tmp1_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
	height = _tmp1_;
	_tmp2_ = game_view_get_theme (self);
	_tmp3_ = _tmp2_;
	if (_tmp3_ == NULL) {
		return;
	}
	_tmp6_ = game_view_get_theme_dimensions (self, &_tmp4_, &_tmp5_);
	theme_width = _tmp4_;
	theme_height = _tmp5_;
	if (!_tmp6_) {
		return;
	}
	_tmp7_ = theme_height;
	_tmp8_ = theme_width;
	aspect = (((gdouble) _tmp7_) / 2) / (((gdouble) _tmp8_) / 43);
	_tmp9_ = game_view_get_game (self);
	_tmp10_ = _tmp9_;
	_tmp11_ = _tmp10_->map;
	_tmp12_ = map_get_width (_tmp11_);
	_tmp13_ = _tmp12_;
	map_width = _tmp13_ + 2.0;
	_tmp14_ = game_view_get_game (self);
	_tmp15_ = _tmp14_;
	_tmp16_ = _tmp15_->map;
	_tmp17_ = map_get_height (_tmp16_);
	_tmp18_ = _tmp17_;
	_tmp19_ = aspect;
	map_height = (_tmp18_ + 2.0) * _tmp19_;
	_tmp20_ = width;
	_tmp21_ = map_width;
	_tmp22_ = height;
	_tmp23_ = map_height;
	_tmp24_ = MIN (_tmp20_ / _tmp21_, _tmp22_ / _tmp23_);
	unit_width = _tmp24_;
	_tmp25_ = unit_width;
	_tmp26_ = aspect;
	unit_height = _tmp25_ * _tmp26_;
	_tmp27_ = unit_width;
	self->priv->tile_width = (gint) (_tmp27_ * 2);
	_tmp28_ = unit_height;
	self->priv->tile_height = (gint) (_tmp28_ * 2);
	_tmp29_ = self->priv->tile_width;
	self->priv->tile_layer_offset_x = _tmp29_ / 7;
	_tmp30_ = self->priv->tile_height;
	self->priv->tile_layer_offset_y = _tmp30_ / 10;
	_tmp31_ = width;
	_tmp32_ = game_view_get_game (self);
	_tmp33_ = _tmp32_;
	_tmp34_ = _tmp33_->map;
	_tmp35_ = map_get_width (_tmp34_);
	_tmp36_ = _tmp35_;
	_tmp37_ = unit_width;
	self->priv->x_offset = ((gint) (_tmp31_ - (_tmp36_ * _tmp37_))) / 2;
	_tmp38_ = height;
	_tmp39_ = game_view_get_game (self);
	_tmp40_ = _tmp39_;
	_tmp41_ = _tmp40_->map;
	_tmp42_ = map_get_height (_tmp41_);
	_tmp43_ = _tmp42_;
	_tmp44_ = unit_height;
	self->priv->y_offset = ((gint) (_tmp38_ - (_tmp43_ * _tmp44_))) / 2;
}


static gboolean game_view_get_theme_dimensions (GameView* self, gint* width, gint* height) {
	gint _vala_width = 0;
	gint _vala_height = 0;
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		RsvgHandle* svg = NULL;
		const gchar* _tmp0_ = NULL;
		const gchar* _tmp1_ = NULL;
		RsvgHandle* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		gint _tmp4_ = 0;
		gint _tmp5_ = 0;
		gint _tmp6_ = 0;
		_tmp0_ = game_view_get_theme (self);
		_tmp1_ = _tmp0_;
		_tmp2_ = rsvg_handle_new_from_file (_tmp1_, &_inner_error_);
		svg = _tmp2_;
		if (_inner_error_ != NULL) {
			goto __catch2_g_error;
		}
		g_object_get (svg, "width", &_tmp3_, NULL);
		_tmp4_ = _tmp3_;
		_vala_width = _tmp4_;
		g_object_get (svg, "height", &_tmp5_, NULL);
		_tmp6_ = _tmp5_;
		_vala_height = _tmp6_;
		result = TRUE;
		_g_object_unref0 (svg);
		if (width) {
			*width = _vala_width;
		}
		if (height) {
			*height = _vala_height;
		}
		return result;
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		gint _tmp10_ = 0;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = game_view_get_theme (self);
		_tmp8_ = _tmp7_;
		gdk_pixbuf_get_file_info (_tmp8_, &_tmp9_, &_tmp10_);
		_vala_width = _tmp9_;
		_vala_height = _tmp10_;
		result = TRUE;
		_g_error_free0 (e);
		if (width) {
			*width = _vala_width;
		}
		if (height) {
			*height = _vala_height;
		}
		return result;
	}
	__finally2:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return FALSE;
}


static void game_view_get_tile_position (GameView* self, Tile* tile, gint* x, gint* y) {
	gint _vala_x = 0;
	gint _vala_y = 0;
	gint _tmp0_ = 0;
	Tile* _tmp1_ = NULL;
	Slot* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	Tile* _tmp5_ = NULL;
	Slot* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	Tile* _tmp10_ = NULL;
	Slot* _tmp11_ = NULL;
	gint _tmp12_ = 0;
	gint _tmp13_ = 0;
	Tile* _tmp14_ = NULL;
	Slot* _tmp15_ = NULL;
	gint _tmp16_ = 0;
	gint _tmp17_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (tile != NULL);
	_tmp0_ = self->priv->x_offset;
	_tmp1_ = tile;
	_tmp2_ = _tmp1_->slot;
	_tmp3_ = _tmp2_->x;
	_tmp4_ = self->priv->tile_width;
	_tmp5_ = tile;
	_tmp6_ = _tmp5_->slot;
	_tmp7_ = _tmp6_->layer;
	_tmp8_ = self->priv->tile_layer_offset_x;
	_vala_x = (_tmp0_ + ((_tmp3_ * _tmp4_) / 2)) + (_tmp7_ * _tmp8_);
	_tmp9_ = self->priv->y_offset;
	_tmp10_ = tile;
	_tmp11_ = _tmp10_->slot;
	_tmp12_ = _tmp11_->y;
	_tmp13_ = self->priv->tile_height;
	_tmp14_ = tile;
	_tmp15_ = _tmp14_->slot;
	_tmp16_ = _tmp15_->layer;
	_tmp17_ = self->priv->tile_layer_offset_y;
	_vala_y = (_tmp9_ + ((_tmp12_ * _tmp13_) / 2)) - (_tmp16_ * _tmp17_);
	if (x) {
		*x = _vala_x;
	}
	if (y) {
		*y = _vala_y;
	}
}


static gint game_view_get_image_offset (GameView* self, gint number) {
	gint result = 0;
	gint set = 0;
	gint _tmp0_ = 0;
	gboolean _tmp1_ = FALSE;
	gint _tmp2_ = 0;
	gboolean _tmp4_ = FALSE;
	gint _tmp5_ = 0;
	gint _tmp7_ = 0;
	gint _tmp9_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = number;
	set = _tmp0_ / 4;
	_tmp2_ = number;
	if (_tmp2_ < 0) {
		_tmp1_ = TRUE;
	} else {
		gint _tmp3_ = 0;
		_tmp3_ = set;
		_tmp1_ = _tmp3_ >= 36;
	}
	_tmp4_ = _tmp1_;
	if (_tmp4_) {
		result = 42;
		return result;
	}
	_tmp5_ = set;
	if (_tmp5_ == 33) {
		gint _tmp6_ = 0;
		_tmp6_ = number;
		result = 33 + (_tmp6_ % 4);
		return result;
	}
	_tmp7_ = set;
	if (_tmp7_ == 35) {
		gint _tmp8_ = 0;
		_tmp8_ = number;
		result = 38 + (_tmp8_ % 4);
		return result;
	}
	_tmp9_ = set;
	if (_tmp9_ == 34) {
		result = 37;
		return result;
	}
	result = set;
	return result;
}


static void game_view_redraw_tile_cb (GameView* self, Tile* tile) {
	gint x = 0;
	gint y = 0;
	Tile* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (tile != NULL);
	game_view_update_dimensions (self);
	_tmp0_ = tile;
	game_view_get_tile_position (self, _tmp0_, &_tmp1_, &_tmp2_);
	x = _tmp1_;
	y = _tmp2_;
	_tmp3_ = self->priv->tile_pattern_width;
	_tmp4_ = self->priv->tile_pattern_height;
	gtk_widget_queue_draw_area ((GtkWidget*) self, x, y, _tmp3_, _tmp4_);
}


static void game_view_paused_changed_cb (GameView* self) {
	g_return_if_fail (self != NULL);
	gtk_widget_queue_draw ((GtkWidget*) self);
}


static gboolean game_view_real_draw (GtkWidget* base, cairo_t* cr) {
	GameView * self;
	gboolean result = FALSE;
	Game* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	cairo_t* _tmp2_ = NULL;
	GdkRGBA _tmp3_ = {0};
	cairo_t* _tmp4_ = NULL;
	cairo_t* _tmp5_ = NULL;
	self = (GameView*) base;
	g_return_val_if_fail (cr != NULL, FALSE);
	_tmp0_ = game_view_get_game (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ == NULL) {
		result = FALSE;
		return result;
	}
	_tmp2_ = cr;
	_tmp3_ = self->background_color;
	gdk_cairo_set_source_rgba (_tmp2_, &_tmp3_);
	_tmp4_ = cr;
	cairo_paint (_tmp4_);
	_tmp5_ = cr;
	game_view_draw_game (self, _tmp5_, FALSE);
	result = TRUE;
	return result;
}


static gboolean game_view_real_button_press_event (GtkWidget* base, GdkEventButton* event) {
	GameView * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	gboolean _tmp7_ = FALSE;
	GdkEventButton _tmp8_ = {0};
	GdkEventType _tmp9_ = 0;
	Tile* tile = NULL;
	GdkEventButton _tmp10_ = {0};
	gdouble _tmp11_ = 0.0;
	GdkEventButton _tmp12_ = {0};
	gdouble _tmp13_ = 0.0;
	Tile* _tmp14_ = NULL;
	gboolean _tmp15_ = FALSE;
	Tile* _tmp16_ = NULL;
	gboolean _tmp21_ = FALSE;
	GdkEventButton _tmp22_ = {0};
	guint _tmp23_ = 0U;
	self = (GameView*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	_tmp1_ = game_view_get_game (self);
	_tmp2_ = _tmp1_;
	if (_tmp2_ == NULL) {
		_tmp0_ = TRUE;
	} else {
		Game* _tmp3_ = NULL;
		Game* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp6_ = FALSE;
		_tmp3_ = game_view_get_game (self);
		_tmp4_ = _tmp3_;
		_tmp5_ = game_get_paused (_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp0_ = _tmp6_;
	}
	_tmp7_ = _tmp0_;
	if (_tmp7_) {
		result = FALSE;
		return result;
	}
	_tmp8_ = *event;
	_tmp9_ = _tmp8_.type;
	if (_tmp9_ != GDK_BUTTON_PRESS) {
		result = FALSE;
		return result;
	}
	_tmp10_ = *event;
	_tmp11_ = _tmp10_.x;
	_tmp12_ = *event;
	_tmp13_ = _tmp12_.y;
	_tmp14_ = game_view_find_tile (self, (guint) _tmp11_, (guint) _tmp13_);
	tile = _tmp14_;
	_tmp16_ = tile;
	if (_tmp16_ == NULL) {
		_tmp15_ = TRUE;
	} else {
		Game* _tmp17_ = NULL;
		Game* _tmp18_ = NULL;
		Tile* _tmp19_ = NULL;
		gboolean _tmp20_ = FALSE;
		_tmp17_ = game_view_get_game (self);
		_tmp18_ = _tmp17_;
		_tmp19_ = tile;
		_tmp20_ = game_tile_can_move (_tmp18_, _tmp19_);
		_tmp15_ = !_tmp20_;
	}
	_tmp21_ = _tmp15_;
	if (_tmp21_) {
		result = TRUE;
		_tile_unref0 (tile);
		return result;
	}
	_tmp22_ = *event;
	_tmp23_ = _tmp22_.button;
	if (_tmp23_ == ((guint) 1)) {
		Game* _tmp24_ = NULL;
		Game* _tmp25_ = NULL;
		Tile* _tmp26_ = NULL;
		Tile* _tmp27_ = NULL;
		Tile* _tmp31_ = NULL;
		Game* _tmp32_ = NULL;
		Game* _tmp33_ = NULL;
		Tile* _tmp34_ = NULL;
		Tile* _tmp35_ = NULL;
		Game* _tmp38_ = NULL;
		Game* _tmp39_ = NULL;
		Tile* _tmp40_ = NULL;
		Tile* _tmp41_ = NULL;
		Tile* _tmp42_ = NULL;
		gboolean _tmp43_ = FALSE;
		_tmp24_ = game_view_get_game (self);
		_tmp25_ = _tmp24_;
		_tmp26_ = game_get_selected_tile (_tmp25_);
		_tmp27_ = _tmp26_;
		if (_tmp27_ == NULL) {
			Game* _tmp28_ = NULL;
			Game* _tmp29_ = NULL;
			Tile* _tmp30_ = NULL;
			_tmp28_ = game_view_get_game (self);
			_tmp29_ = _tmp28_;
			_tmp30_ = tile;
			game_set_selected_tile (_tmp29_, _tmp30_);
			result = TRUE;
			_tile_unref0 (tile);
			return result;
		}
		_tmp31_ = tile;
		_tmp32_ = game_view_get_game (self);
		_tmp33_ = _tmp32_;
		_tmp34_ = game_get_selected_tile (_tmp33_);
		_tmp35_ = _tmp34_;
		if (_tmp31_ == _tmp35_) {
			Game* _tmp36_ = NULL;
			Game* _tmp37_ = NULL;
			_tmp36_ = game_view_get_game (self);
			_tmp37_ = _tmp36_;
			game_set_selected_tile (_tmp37_, NULL);
			result = TRUE;
			_tile_unref0 (tile);
			return result;
		}
		_tmp38_ = game_view_get_game (self);
		_tmp39_ = _tmp38_;
		_tmp40_ = game_get_selected_tile (_tmp39_);
		_tmp41_ = _tmp40_;
		_tmp42_ = tile;
		_tmp43_ = tile_matches (_tmp41_, _tmp42_);
		if (_tmp43_) {
			Game* _tmp44_ = NULL;
			Game* _tmp45_ = NULL;
			Game* _tmp46_ = NULL;
			Game* _tmp47_ = NULL;
			Tile* _tmp48_ = NULL;
			Tile* _tmp49_ = NULL;
			Tile* _tmp50_ = NULL;
			gboolean _tmp51_ = FALSE;
			_tmp44_ = game_view_get_game (self);
			_tmp45_ = _tmp44_;
			_tmp46_ = game_view_get_game (self);
			_tmp47_ = _tmp46_;
			_tmp48_ = game_get_selected_tile (_tmp47_);
			_tmp49_ = _tmp48_;
			_tmp50_ = tile;
			game_remove_pair (_tmp45_, _tmp49_, _tmp50_);
			_tmp51_ = self->auto_play;
			if (_tmp51_) {
				Game* _tmp52_ = NULL;
				Game* _tmp53_ = NULL;
				_tmp52_ = game_view_get_game (self);
				_tmp53_ = _tmp52_;
				game_auto_move (_tmp53_);
			}
			result = TRUE;
			_tile_unref0 (tile);
			return result;
		} else {
			Game* _tmp54_ = NULL;
			Game* _tmp55_ = NULL;
			Tile* _tmp56_ = NULL;
			_tmp54_ = game_view_get_game (self);
			_tmp55_ = _tmp54_;
			_tmp56_ = tile;
			game_set_selected_tile (_tmp55_, _tmp56_);
			result = TRUE;
			_tile_unref0 (tile);
			return result;
		}
	}
	result = FALSE;
	_tile_unref0 (tile);
	return result;
}


static Tile* game_view_find_tile (GameView* self, guint x, guint y) {
	Tile* result = NULL;
	cairo_surface_t* surface = NULL;
	cairo_surface_t* _tmp0_ = NULL;
	cairo_t* cr = NULL;
	cairo_surface_t* _tmp1_ = NULL;
	cairo_t* _tmp2_ = NULL;
	cairo_t* _tmp3_ = NULL;
	cairo_t* _tmp4_ = NULL;
	cairo_t* _tmp5_ = NULL;
	guint _tmp6_ = 0U;
	guint _tmp7_ = 0U;
	cairo_t* _tmp8_ = NULL;
	guchar* data = NULL;
	cairo_surface_t* _tmp9_ = NULL;
	guchar* _tmp10_ = NULL;
	gint data_length1 = 0;
	gint _data_size_ = 0;
	guchar number = '\0';
	guchar* _tmp11_ = NULL;
	gint _tmp11__length1 = 0;
	guchar _tmp12_ = '\0';
	Game* _tmp13_ = NULL;
	Game* _tmp14_ = NULL;
	GList* _tmp15_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = cairo_image_surface_create (CAIRO_FORMAT_RGB24, 1, 1);
	surface = _tmp0_;
	_tmp1_ = surface;
	_tmp2_ = cairo_create (_tmp1_);
	cr = _tmp2_;
	_tmp3_ = cr;
	cairo_set_source_rgba (_tmp3_, (gdouble) 255, (gdouble) 255, (gdouble) 255, (gdouble) 255);
	_tmp4_ = cr;
	cairo_paint (_tmp4_);
	_tmp5_ = cr;
	_tmp6_ = x;
	_tmp7_ = y;
	cairo_translate (_tmp5_, (gdouble) (-_tmp6_), (gdouble) (-_tmp7_));
	_tmp8_ = cr;
	game_view_draw_game (self, _tmp8_, TRUE);
	_tmp9_ = surface;
	_tmp10_ = cairo_image_surface_get_data (_tmp9_);
	data = _tmp10_;
	data_length1 = -1;
	_data_size_ = data_length1;
	_tmp11_ = data;
	_tmp11__length1 = data_length1;
	_tmp12_ = _tmp11_[0];
	number = _tmp12_;
	_tmp13_ = game_view_get_game (self);
	_tmp14_ = _tmp13_;
	_tmp15_ = _tmp14_->tiles;
	{
		GList* tile_collection = NULL;
		GList* tile_it = NULL;
		tile_collection = _tmp15_;
		for (tile_it = tile_collection; tile_it != NULL; tile_it = tile_it->next) {
			Tile* _tmp16_ = NULL;
			Tile* tile = NULL;
			_tmp16_ = _tile_ref0 ((Tile*) tile_it->data);
			tile = _tmp16_;
			{
				Tile* _tmp17_ = NULL;
				gint _tmp18_ = 0;
				guchar _tmp19_ = '\0';
				_tmp17_ = tile;
				_tmp18_ = _tmp17_->number;
				_tmp19_ = number;
				if (_tmp18_ == ((gint) _tmp19_)) {
					result = tile;
					_cairo_destroy0 (cr);
					_cairo_surface_destroy0 (surface);
					return result;
				}
				_tile_unref0 (tile);
			}
		}
	}
	result = NULL;
	_cairo_destroy0 (cr);
	_cairo_surface_destroy0 (surface);
	return result;
}


Game* game_view_get_game (GameView* self) {
	Game* result;
	Game* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_game;
	result = _tmp0_;
	return result;
}


static gpointer _game_ref0 (gpointer self) {
	return self ? game_ref (self) : NULL;
}


static void _game_view_redraw_tile_cb_game_redraw_tile (Game* _sender, Tile* tile, gpointer self) {
	game_view_redraw_tile_cb (self, tile);
}


static void _game_view_paused_changed_cb_game_paused_changed (Game* _sender, gpointer self) {
	game_view_paused_changed_cb (self);
}


void game_view_set_game (GameView* self, Game* value) {
	Game* _tmp0_ = NULL;
	Game* _tmp1_ = NULL;
	Game* _tmp2_ = NULL;
	Game* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _game_ref0 (_tmp0_);
	_game_unref0 (self->priv->_game);
	self->priv->_game = _tmp1_;
	_tmp2_ = self->priv->_game;
	g_signal_connect_object (_tmp2_, "redraw-tile", (GCallback) _game_view_redraw_tile_cb_game_redraw_tile, self, 0);
	_tmp3_ = self->priv->_game;
	g_signal_connect_object (_tmp3_, "paused-changed", (GCallback) _game_view_paused_changed_cb_game_paused_changed, self, 0);
	_tmp4_ = self->auto_play;
	if (_tmp4_) {
		Game* _tmp5_ = NULL;
		_tmp5_ = self->priv->_game;
		game_auto_move (_tmp5_);
	}
	gtk_widget_queue_draw ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "game");
}


const gchar* game_view_get_theme (GameView* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_theme;
	result = _tmp0_;
	return result;
}


void game_view_set_theme (GameView* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_theme);
	self->priv->_theme = _tmp1_;
	_cairo_pattern_destroy0 (self->priv->tile_pattern);
	self->priv->tile_pattern = NULL;
	gtk_widget_queue_draw ((GtkWidget*) self);
	g_object_notify ((GObject *) self, "theme");
}


static void game_view_class_init (GameViewClass * klass) {
	game_view_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GameViewPrivate));
	GTK_WIDGET_CLASS (klass)->draw = game_view_real_draw;
	GTK_WIDGET_CLASS (klass)->button_press_event = game_view_real_button_press_event;
	G_OBJECT_CLASS (klass)->get_property = _vala_game_view_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_game_view_set_property;
	G_OBJECT_CLASS (klass)->finalize = game_view_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GAME_VIEW_GAME, param_spec_game ("game", "game", "game", TYPE_GAME, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GAME_VIEW_THEME, g_param_spec_string ("theme", "theme", "theme", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void game_view_instance_init (GameView * self) {
	self->priv = GAME_VIEW_GET_PRIVATE (self);
	self->priv->tile_pattern = NULL;
	self->priv->tile_pattern_width = 0;
	self->priv->tile_pattern_height = 0;
	self->auto_play = FALSE;
	self->priv->_theme = NULL;
}


static void game_view_finalize (GObject* obj) {
	GameView * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_GAME_VIEW, GameView);
	_cairo_pattern_destroy0 (self->priv->tile_pattern);
	_game_unref0 (self->priv->_game);
	_g_free0 (self->priv->_theme);
	G_OBJECT_CLASS (game_view_parent_class)->finalize (obj);
}


GType game_view_get_type (void) {
	static volatile gsize game_view_type_id__volatile = 0;
	if (g_once_init_enter (&game_view_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GameViewClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) game_view_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GameView), 0, (GInstanceInitFunc) game_view_instance_init, NULL };
		GType game_view_type_id;
		game_view_type_id = g_type_register_static (GTK_TYPE_DRAWING_AREA, "GameView", &g_define_type_info, 0);
		g_once_init_leave (&game_view_type_id__volatile, game_view_type_id);
	}
	return game_view_type_id__volatile;
}


static void _vala_game_view_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GameView * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_GAME_VIEW, GameView);
	switch (property_id) {
		case GAME_VIEW_GAME:
		value_set_game (value, game_view_get_game (self));
		break;
		case GAME_VIEW_THEME:
		g_value_set_string (value, game_view_get_theme (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_game_view_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GameView * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_GAME_VIEW, GameView);
	switch (property_id) {
		case GAME_VIEW_GAME:
		game_view_set_game (self, value_get_game (value));
		break;
		case GAME_VIEW_THEME:
		game_view_set_theme (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



